<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0062)https://edu.pjwstk.edu.pl/wyklady/ppj/scb/NapLicz/NapLicz.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Podstawy programowania w jÍzyku Java (PRG1, PPJ)">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2008">
  <link rel="stylesheet" type="text/css" href="./Przetwarzanie danych_ napisy i liczby_files/common.css">   
  <title>Przetwarzanie danych: napisy i liczby</title>
</head>
<body>
<div align="Center">
<a name="NapLicz"></a><h1>Przetwarzanie danych: napisy i liczby</h1>
<hr>
</div>

<a name="NapLicz.1"></a><h2>1.  Napisy modyfikowalne</h2>

Pewnπ zaskakujπcπ moøe w≥aúciwoúciπ <a name="ind.NapLicz.1"></a>klasy String jest to, øe jej
obiekty sπ <b>niemodyfikowalne</b> - to znaczy utworzonych
za pomocπ klasy String napisÛw nie moøemy zmieniaÊ (np. do napisu dodaÊ
inny). <br>
Jak to ? Przecieø wielokrotnie zajmowaliúmy siÍ konkatenacjπ ≥aÒcuchÛw.<br>
No tak, ale wynikowy napis, powstajπcy z dodania do ≥aÒcucha znakowego
innego napisu, <b>jest nowym obiektem</b> i np. w takiej
sekwencji:<br>
<br>String s = "Ala";<br>
s = s + " ma kota";<br>
<br>tworzony jest nowy obiekt, zawierajπcy napis "Ala ma kota" i
referencja do
niego przypisywana jest zmiennej s, ktÛra poprzednio zawiera≥a
referencjÍ do napisu "Ala".<br>
<br>ZwrÛÊmy teø uwagÍ, øe w klasie String nie ma øadnych metod
pozwalajπcych modyfikowaÊ istniejπcy obiekt-napis.<br><br>NiemodyfikowalnoúÊ
klas jest zaletπ: zwiÍksza niezawodnoúÊ programowania.<br>
Czasami jednak zmiany obiektÛw napisÛw sπ potrzebne. <br>
<br><div class="important"><a name="ind.NapLicz.2"></a>Modyfikowalne
obiekty-≥aÒcuchy znakowe definiujπ klasy <b>StringBuffer</b>
i&nbsp;StringBuilder.</div><br>
<br><a name="ind.NapLicz.3"></a>Obiekty klas StringBuffer (i StringBuilder) to "bufory",
ktÛre dynamicznie moøemy wype≥niaÊ
napisami. W szczegÛlnoúci moøemy utworzyÊ pusty - na razie - bufor:<br>
<br>StringBuffer sb = new StringBuffer();<br>
<br>po czym wypelniaÊ go zawartoúciπ dopisujπc do niego jakieú
kolejne napisy, znaki lub liczby (znakowe reprezentacje liczb), lun
napisowe reprezentacje obiektÛw:<br>
<br>sb.append("jakiú napis 1");<br>
sb.append("jakiú napis 2");<br>sb.append(10);<br>sb.append('\n');<br>sb.append
(new Para(1,2));<br>
...<br>
<br>Metoda append zwraca StringBuffer wobec tego moøemy
&nbsp;to samo zapisaÊ jako:<br><br>
sb.append("jakiú napis 1").append("jakiú napis
2").sb.append(10).sb.append('\n').append(new Para(1,2));<br><br>Inne
metody klasy StringBuffer pozwalajπ m.in.&nbsp; na pobieranie i
usuwanie fragmentÛw napisu, wstawianie napisÛw, wyszukiwanie itp. <br><br>Obiekt
klasy StringBuffer ≥atwo moøna przekszta≥ciÊ w obiekt klasy String za
pomocπ metod toString():<br>
<br>String s = sb.toString();<br>
<br><a name="ind.NapLicz.4"></a>Klasa StringBuilder ma takie same metody jak StringBuffer.<br>
<br>Wykorzystanie klasy StringBuffer lub StringBuilder zamiast
String
jest wskazane przy duøej liczbie "kumulatywnych" operacji konkatenacji,
bo dziÍki temu uzyskujemy wielokrotnie wyøszπ efektywnoúÊ dzia≥ania
programu (<span style="font-weight: bold;">przy naprawdÍ
duøej -
powiedzmy ponad 10 tys.-&nbsp; operacji np. w pÍtli, uøycie klasy
String i operatora + jest wrÍcz niedopuszczalne</span>).<br><br>Uwaga:
rÛønica miÍdzy StringBufferem i StringBuilderem polega tylko na tym, øe
ten pierwszy zapewnia synchronizacjÍ dostÍpu z rÛwnolegle wykonujπcych
siÍ fragmentÛw kodu, a wobec tego jest nieco mniej efektywny; jednak ta
w≥aúciwoúÊ jest niezbÍdna w programowaniu wspÛ≥bieønym. <br><br>
RÛønicÍ pomiÍdzy uøyciem String i StringBuffera pokazuje poniøszy
program.<br>
Do mierzenia czasu operacji korzystamy w nim z klasy QTimer, w ktÛrej
zdefiniowaliúmy
metodÍ getElapsed() zwracajπcπ up≥yw czasu od momentu utworzenia
obiektu tej
klasy. Czas mierzymy za pomocπ statycznej metody klasy System
currentTimeMillis(),
ktÛra zwraca bieøπcy czas w milisekundach.<pre>import javax.swing.*;

class QTimer {

   private final long start;

   public QTimer() {
     System.gc();
     start = System.currentTimeMillis();
   }

   public long getElapsed() {
      return System.currentTimeMillis() - start;
   }
}

public class Test {


  public static void main(String args[]) throws InterruptedException {

    int n = Integer.parseInt(JOptionPane.showInputDialog("Liczba operacji"));

    // String
    QTimer t = new QTimer();
    String strA = "";
    for (int i = 1; i &lt;= n; i++)  strA += "A";
    long etA = t.getElapsed();
    System.out.println("String operator +;   Czas: " + etA  + " ms");

    // StringBuffer
    t = new QTimer();
    StringBuffer sb = new StringBuffer();
    for (int i = 1; i &lt;= n; i++) sb.append("B");
    sb.toString();  
    long etB = t.getElapsed();
    System.out.println("StringBuffer append. Czas: " +  etB + " ms");  
 
    System.out.println("Wykonano " + n + " operacji.");
    System.out.println("Relacja String/StringBuffer  = " + (double) etA/etB); 
  }
}


</pre>
Moøliwy wynik:<br><div class="listing100">String
operator +;&nbsp;&nbsp; Czas: 58875 ms<br>StringBuffer
append. Czas: 15 ms<br>Wykonano 90000 operacji.<br>Relacja
String/StringBuffer&nbsp; =&nbsp;3925.0</div><br><hr style="width: 100%; height: 2px;">
<a name="NapLicz.2"></a><h2>2.  Pliki tekstowe</h2>
Potrafimy
juø odczytaÊ informacjÍ z pliku tekstowego (zob. punkty nt. czytania
informacji z pliku za pomocπ skanera w poprzednim materiale). A jak jπ
zapisaÊ do pliku? I czy skaner to jedyny moøliwy sposÛb?<br><br>Bardziej
ogÛlnym i uniwersalnym sposobem jest zastosowanie tzw. klas
strumieniowych z pakietu java.io.<br>O koncepcji tej i jej
szczegÛ≥ach bÍdzie mowa w przysz≥ym semestrze. Teraz zajmiemy siÍ
wycinkiem tej problematyki,
skrÛtowo i niejako czysto "instruktaøowo".<br><br>
OgÛlnie, pliki <b>jako ciπgi bajtÛw </b>(powiemy: pliki
bajtowe) sπ w Javie reprezentowane przez obiekty
klas strumieniowych FileInputStream (pliki wejúciowe - z ktÛrych
wczytujemy dane) i FileOutputStream
(pliki wyjúciowe - do ktÛrych zapisujemy dane).<br>
<br><a name="ind.NapLicz.5"></a>Przygotowanie pliku do przetwarzania przez program nazywa siÍ
<b>otwarciem</b> pliku.<br> W Javie pliki sπ
otwierane automatycznie przy tworzeniu plikowych obiektÛw
strumieniowych
(czyli obiektÛw oznaczajπcych pliki, w tym obiektÛw wspomnianych wyøej
klas&nbsp;FileInputStream
i&nbsp;FileOutputStream).<br><a name="ind.NapLicz.6"></a>
Obiekty-pliki <b>bajtowe</b> moøemy tworzyÊ za pomocπ
konstruktorÛw klas
FileInputStream i
FileOutputStream, podajπc jako argument nazwÍ pliku.<br>
<br>Np. <br><pre>FileInputStream in = new FileInputStream("Program1.java"); &nbsp; &nbsp; &nbsp; // gdy nie podano úciezki,
FileOutputStream out = new FileOutputStream("Program2.java"); // pliki&nbsp;w katalogu roboczym aplikacji
lub

FileInputStream in = new FileInputStream("C:/Test/Program1.java"); &nbsp; // z podanπ úciezkπ
FileOutputStream out = new FileOutputStream("C:\\Test\\Program2.java"); // uwaga na symbol "escape"! </pre><br>
Z plikÛw bajtowych moøemy czytaÊ bajty za pomocπ metody <b>int
read() </b>i moøemy do nich zapisywaÊ bajty za pomocπ metody <b>write(int)</b>.<br>
ZwrÛÊmy uwagÍ - bajty doskonale mieszczπ siÍ w zmiennej typu byte, ale
read()
zwraca wartoúÊ typu int, gdyø&nbsp; przy prÛbie czytania bajtÛw
spoza koÒca pliku&nbsp;
musi jakoú poinformowaÊ o koÒcu pliku. Umownie zwraca wtedy wartoúÊ -1
(typu
int), co oczywiúcie jest zupe≥nie innπ wartoúciπ niø wszelkie moøliwe
wartoúci
bajtÛw. <br>
<br><a name="ind.NapLicz.7"></a>Po wykonaniu operacji na pliku powinniúmy plik <b>zamknπÊ</b>,
co np. powoduje
ostateczny, fizyczny zapis informacji, byÊ moøe do tego momentu bÍdπcej
jeszcze
w buforach systemowych oraz inne dzia≥ania porzπdkowe na poziomie
systemu
operacyjnego (niekiedy np. zwiπzane z moøliwoúciπ udostÍpnienia pliku
innym
programom, lub z umoøliwieniem otwarcia przez nasz program innych
plikÛw).
<br><br>
Do zamykania plikÛw s≥uøy metoda <b>close()</b>.<br>
<br>Moøemy teraz napisaÊ program, ktÛry - bajt po bajcie -
kopiuje dowolny plik
wejúciowy do dowolnego pliku wyjúciowego. Nazwy plikÛw podajemy jako
argumenty
wywo≥ania programu.<br>
<br><pre>import java.io.*;
import static javax.swing.JOptionPane.*;

public class CopyFile {

  public static void main(String[] args) {

    FileInputStream in = null;   // plik wejúciowy
    FileOutputStream out = null; // plik wyjúciowy

    try {
      in = new FileInputStream("in1");
      out = new FileOutputStream("out1");
      int c;
      while ((c = in.read()) != -1)  out.write(c);    // kopiowanie
    } catch (ArrayIndexOutOfBoundsException exc) {    // brak argumentu
        System.out.println("Syntax: CopyFile in out");
        System.exit(1);
    } catch (FileNotFoundException exc) {             // nieznany plik
        System.out.println("Plik wejúciowy nie istnieje.");
        System.exit(2);
    } catch (IOException exc) {                       // inny b≥πd wejúcia- wyjúcia
        System.out.println(exc.toString());
        System.exit(3);
    } finally {                     // zawsze zamykamy pliki
        try {                       // niestety close moøe zg≥osiÊ wyjatek kontrolowany - trzeba uøyÊ try
          if (in != null) in.close();
          if (out != null) out.close();
      } catch (IOException exc) {
          System.out.println(exc.toString());
      }
    }
  }

}
</pre>
<br><a name="ind.NapLicz.8"></a>Kaødy plik jest sekwencjπ bajtÛw. Ale znaczenie bajtÛw moøe
byÊ bardzo rÛøne.
Mogπ to byÊ np. binarne reprezentacje jakichú liczb, albo mogπ to byÊ
znaki
(wtedy bÍdziemy mÛwiÊ o plikach tekstowych).<br>
<br>ZwrÛÊmy jednak uwagÍ, øe w Javie znaki sπ przedstawiane w
Unicodzie (czyli
jako wartoúci dwubajtowe). Jeøeli tekst w pliku zapisany jest w ten
w≥aúnie sposÛb
- to nie ma problemu. Ale czÍsto pliki tekstowe zapisywane sπ w rÛønych
systemach
kodowania, niekoniecznie w Unicodzie. SposÛb kodowania znakÛw tekstu
nazywa
siÍ stronπ kodowπ. Np. wiele polskich dokumentÛw HTML zapisanych jest z
wykorzystaniem
strony&nbsp; kodowej ISO8859-2, inne - z wykorzystaniem strony
Cp1250 (inaczej
zwanej Windows 1250). To oczywiúcie nie jest Unicode - znaki zajmujπ 1
bajt.<br><br><a name="ind.NapLicz.9"></a>
W kaødym systemie operacyjnym &nbsp;moøemy teø ustawiÊ tzw.
domyúlnπ stronÍ kodowπ,
ktÛra bÍdzie wykorzystywana np. przy wczytywaniu i zapisie plikÛw przez
systemowe
edytory tekstu. Np. w systemie Windows takπ domyúlnπ stronπ kodowπ
najczÍúciej jest - w polskich warunkach - Cp1250.<br>
Przy wczytywaniu Java musi dokonaÊ przekodowania plikÛw zapisanych w
domyúlnej
stronie kodowej na Unicode, a przy zapisie wykonaÊ operacjÍ odwrotnπ -
przekodowania
z Unicodu do domyúlnej strony kodowej.<br>Metody klas
FileInputStream i FileOutputStream
- nie wykonujπ tego zadania (czytajπ i piszπ bajt po bajcie, co w
przypadku
plikÛw tekstowych moøe powodowaÊ utratÍ informacji.<br>
Zobaczmy przyk≥ad.<br>
Poniøszy program.<br>
<pre>import java.io.*;

public class ReadBytesAsChars {

 public static void main(String[] args) {
   StringBuffer cont = new StringBuffer();

   try {
     FileInputStream in = new FileInputStream(args[0]);
     int c;
     while ((c = in.read()) != -1) cont.append((char) c);
     in.close();
   } catch(Exception exc) {
       System.out.println(exc.toString());
       System.exit(1);
   }
   String s = cont.toString();
   System.out.println(s);
 }

}
</pre>czyta
plik tekstowy i zapisuje jego zawartoúÊ w ≥aÒcuchu znakowym (String),
po czym wypisuje na konsoli &nbsp;ten ≥aÒcuch znakowy. Jeúli
przeczytaliúmy z
pliku zapisanego w Cp1250 nastÍpujπcy tekst:<br>
<br>Poczπtek <br>
pog≥Íbienia <br>
znajomoúci <br>
Javy<br>
<br>to na konsoli uzyskamy:<br>
<br>Pocz?tek<br>
pog??bienia<br>
znajomo?ci<br>
Javy<br>
<a name="ind.NapLicz.10"></a><br>Takich strat informacji nie bÍdzie, jeúli do czytania plikÛw
wykorzystamy
obiekt klasy <b>FileReader</b>, a do zapisywania - <b>FileWriter</b>,
bowiem klasy te zapewniajπ
konwersje miÍdzy domyúlnπ stronπ kodowπ systemu operacyjnego
i&nbsp; Unicodem<br>
<br><div class="important">Do przetwarzania plikÛw
tekstowych naleøy wykorzystywaÊ klasy FileReader i FileWriter</div><br>
&nbsp;<br>
Poprzedni przyk≥ad moøemy teraz zapisaÊ tak:<br>
<pre>import java.io.*;

public class ReadByReader {

 public static void main(String[] args) {
   StringBuffer cont = new StringBuffer();

   try {
     FileReader in = new FileReader(args[0]);
     int c;
     while ((c = in.read()) != -1) cont.append((char) c);
     in.close();
   } catch(Exception exc) {
     System.out.println(exc.toString());
     System.exit(1);
   }
   String s = cont.toString();
   System.out.println(s);
 }

}
</pre><br>
Przy przetwarzaniu plikÛw zetkniemy siÍ takøe z kwestiπ efektywnoúci.<br>
Np. przy czytaniu duøych plikÛw tekstowych naleøy unikaÊ bezpoúredniego
czytania za pomocπ klasy FileReader, bowiem kaøde odczytanie znaku moøe
powodowaÊ
fizyczne odwo≥anie do pliku (to samo dotyczy zapisu i klasy
FileWriter).
<br>Operacje fizycznych odwo≥aÒ do pliku (dysku) sπ czasoch≥onne.<br><a name="ind.NapLicz.11"></a>
Aby je ograniczyÊ - stosujemy tzw. buforowanie.<br> W pamiÍci
operacyjnej
wydzielany jest duøy obszar pamiÍci, ktÛry zape≥niany jest przez
jednorazowe
fizyczne odwo≥anie do pliku. Instrukcje czytania pliku pobierajπ
informacje
z tego bufora. Gdy bufor jest pusty - nastÍpuje kolejne jego
wype≥nienie poprzez
fizyczne odwo≥anie do pliku. W ten sposÛb liczba fizycznych odwo≥aÒ do
pliku
(do dysku) jest mniejsza niø liczba zapisanych w programie instrukcji
czytania
danych.<br>
<br>W Javie do buforowania wejúciowych plikÛw tekstowych
stosujemy <a name="ind.NapLicz.12"></a>klasÍ BufferedReader. <br>
Ale klasa ta nie pozwala - przy tworzeniu obiektÛw - bezpoúrednio, w
konstruktorze ,
podawaÊ ürÛd≥a danych (np. nazwy pliku).
<br>èrÛd≥o to podajemy przy tworzeniu obiektu typu FileReader, a
po to,
øeby uzyskaÊ buforowanie, "opakowujemy" FileReader -&nbsp;
BufferedReaderem.
<br><br>Wyglπda to tak:<br><pre>// tu powstaje zwiπzek z fizycznym ürÛd≥em
FileReader fr = new FileReader("plik.txt"); 

// tu dodajemy "opakowanie", umoøliwiajπce buforowanie 
BufferedReader br = new BufferedReader(fr);

//... teraz wszelkie odwo≥ania czytania itp. kierujemy do obiektu br
</pre><a name="ind.NapLicz.13"></a>Dodatkowo
w klasie BufferedReader zdefiniowano wygodnπ metodÍ czytania wierszy
pliku: <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
readLine()<br><br>ktÛra zwraca kolejny wiersz jako String
lub null jeúli wystπpi≥ koniec pliku<br><br>Zarys czytania:<br><pre> try {
   String line;
   FileReader fr = new FileReader(fname); // fname jest nazwπ pliku
   BufferedReader br = new BufferedReader(fr);

   while ((line = br.readLine()) != null) { // kolejny wiersz pliku: metoda readLine
      ...
      // tu robimy coú z wierszami pliku
   }
   br.close(); // zamkniÍcie pliku
 } catch (IOException e) {
     e.printStackTrace();
 } </pre>i
jego realizacja na przyk≥adzie poprzedniego programu:<br><pre>import java.io.*;

public class BuffRead {

  public static void main(String[] args) {
    
    try {
      BufferedReader in = new BufferedReader(
                              new FileReader("in1"));
      StringBuffer sb = new StringBuffer();
      String line;
      while ((line = in.readLine()) != null) {
        sb.append(line).append('\n');
      }
      in.close();
      System.out.println(sb);
    } catch (IOException exc) {
      exc.printStackTrace();
    }

  }

}</pre><a name="ind.NapLicz.14"></a>Naturalnie,
do czytania plikÛw tekstowych zapisanych w domyúlnej stronie kodowej
nieco wygodniejszy jest Scanner.<br>Przypomnijmy schemat:<br><pre>import java.io.*;
import java.util.*;

public class ScanRead {

  public static void main(String[] args) {
    StringBuffer sb = new StringBuffer();
    try {
      Scanner scan = new Scanner(new File("in1"));
      while (scan.hasNextLine()) {
        sb.append(scan.nextLine()).append('\n');
      }
      scan.close();
      System.out.println(sb);
    } catch (FileNotFoundException exc) {
      exc.printStackTrace();
    }

  }

}</pre><a name="ind.NapLicz.15"></a>Ale
do zapisywania plikÛw musimy uøywaÊ klas strumieniowych.<br>Buforowany
zapis plikÛw tekstowych uzyskaÊ moøna przez&nbsp;opakowanie obiektu
klasy FileWriter w obiekt klasy&nbsp;BufferedWriter. Do zapisu tekstu
uøywamy metody write(String). Dodatkowo klasa BuffredWriter posiada
wygodnπ metodÍ newLine(), ktÛra dopisuje w≥aúciwy&nbsp;dla danej
platformy systemowej&nbsp;znak koÒca wiersza (0d0aX w Windows, 0aX
-
Unix).<br><br>Przyk≥ad: kopiowanie plikÛw tekstowych z
buforowaniem odczytu i zapisu.<br><pre>public class BuffTextFileCopy {

  public static void main(String[] args) {
    BufferedReader in = null;
    BufferedWriter out = null;
    
    try {
      in = new BufferedReader(new FileReader("in1"));
      out = new BufferedWriter(new FileWriter("out1"));
      String line;
      while ((line = in.readLine()) != null) {
        out.write(line);
        out.newLine();
      }
    } catch (IOException exc) {
      exc.printStackTrace();
    } finally {
      try {
        if (in != null) in.close();
        if (out != null) out.close();
      } catch(IOException exc) {
        exc.printStackTrace();
      }
    }

  }

}</pre><a name="ind.NapLicz.16"></a>Przy
zapisie buforowanych plikÛw waøne jest, aby po zakoÒczeniu zapisu
zawsze je zamykaÊ. W przeciwnym razie czÍúÊ (lub ca≥oúÊ) informacji
moøe pozostaÊ w buforze i nie trafiÊ do pliku. Dlatego zamkniÍcie
plikÛw umieúciliúmy w klauzuli finally, ktÛra wykona siÍ zawsze
&nbsp;bez wzglÍdu na to czy powstanπ jakieú wyjπtki czy nie.<br><br><a name="ind.NapLicz.17"></a>Na
zakoÒczenie tego krÛtkiego wprowadzenia do przetwarzania plikÛw
tekstowych warto zwrÛciÊ uwagÍ na nastÍpujπce kwestie:<br><ul><li>klasa
File nie zawiera øadnych metod odczytu lub zapisu plikÛw, s≥uøy ona
abstrakcyjnemu oznaczaniu obiektÛw plikowych i dostarcza metod uzyskiwania o nich
informacji,</li><li>referencje do obiektÛw klasy File
moøemy jednak podawaÊ w konstruktorach klas FileReader, FileWriter
i&nbsp; Scanner, uzyskujπc w ten sposÛb dostÍp do operacji czytania
plikÛw lub ich zapisu,</li><li>skanerowi - jako ürÛd≥o
danych - moøemy podawaÊ oprÛcz File rÛwnieø FileReader lub
BufferedReader.</li><li><a name="ind.NapLicz.18"></a>przy
wykorzystaniu klas&nbsp;strumieniowych moøemy dokonywaÊ dekodowania
(zamiana na Unicode przy wczytywaniu) i kodowania (zamiana na kodowanie
dla danej strony kodowej przy zapisie) &nbsp;tekstÛw dla dowolnych
stron kodowych - s≥uøπ temu klasy InputStreamReader i
OutputStreamWriter; przy zastosowaniu skanera sytuacja jest nieco
prostsza: moøna podaÊ w konstruktorze stronÍ kodowa wczytywanego pliku
i bÍdzie dokonana translacja jego treúci do Unicodu np.</li></ul><pre>File file = new File("tekst.txt");

// za≥Ûømy, øe plik jest zapisany w stronie kodowej ISO8859-2
// normalnie skaner dokonuje dekodowania do domyúlnej strony kodowej na danej platformie
// jeúli nie jest to ISO8859-2, to plik nie zostanie w≥aúciwie odczytany
// moøemy jednak podaÊ z jakiej strony kodowej ma byÊ dekodowanie

Scanner scan = new Scanner(file, "ISO8859-2");

// i teraz zawartoúÊ pliku bÍdzie w≥πsciwie przekszta≥cona do Unicodu
&nbsp;&nbsp;&nbsp;</pre><br><hr style="width: 100%; height: 2px;">

<a name="NapLicz.3"></a><h2>3.  Metody klasy String</h2>
W praktycznych programach
bardzo czÍsto bÍdziemy operowaÊ na ≥aÒcuchach
znakowych (napisach). Wiemy doskonale, øe sπ one reprezentowane przez
obiekty
klasy String. W klasie tej znajdziemy wiele uøytecznych metod
przeznaczonych
do operowania na ≥aÒcuchach znakowych.<br>
<br>DokumentacjÍ klas i ich metod standardowych pakietÛw Javy
znajdziemy w podkatalogu
docs katalogu instalacyjnego Javy. Jest ona w postaci HTML: klasy
podzielone
sπ wed≥ug pakietÛw a takøe dostÍpna jest alfabetyczna lista wszystkich
klas.<br>
<br><a name="ind.NapLicz.19"></a>Dla wygody poniøej przedstawiono wybrane metody klasy String.<br>
ZwrÛÊmy uwagÍ, øe:<br>
<ul><li>kolejne znaki napisÛw wystÍpujπ na pozycjach, ktÛre
sπ indeksowane
poczynajπc od 0: np. napis "Ala" ma trzy znaki na pozycjach 1, 2, 3;
pierwsza
pozycja ma indeks 0, druga - 1, trzecia 2. Moøemy teø powiedzieÊ, øe
pierwszy
znak ma indeks 0, a ostatni - indeks o 1 mniejszy od d≥ugoúci napisu,</li><li>czÍúci
napisÛw (≥aÒcuchÛw znakowych) okreúla siÍ terminem "pod≥aÒcuch"
(substring),</li><li>wiÍkszoúÊ z omawianych dalej metod
(wszystkie metody niestatyczne)
uøywana jest "na rzecz" obiektÛw klasy String; o obiekcie na rzecz
ktÛrego
wywo≥ano metodÍ mÛwimy <i><b>ten</b></i> napis,<br></li><li>przedstawiono
tu nie wszystkie metody klasy String, a jedynie te najbardziej
uøyteczne.<br></li></ul>
<br><br>
<table style="width: 100%;" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td colspan="2"><div align="center"><span style="font-weight: bold;">Wybrane
metody klasy String</span><br></div></td></tr><tr><td style="width: 1%; vertical-align: top; text-align: right; white-space: nowrap;">
char</td><td><span style="font-weight: bold;">charAt(int
index)</span><br> Zwraca znak na pozycji, oznaczonej
indeksem index. Pierwsza pozycja ma indeks 0.</td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">compareTo(String anotherString)</span><br>
PorÛwnuje dwa napisy: ten (this) na rzecz ktÛrego uøyto metody oraz
przekazany jako argument.<br>
Metoda zwraca 0, gdy napisy sπ takie same.<br>
Jeøeli siÍ rÛøniπ, to - gdy wystÍpujπ w nich rÛøne znaki - zwracana
jest wartoúÊ: <br> this.charAt(k) - anotherString.charAt(k), <br>
gdzie k - indeks pierwszej pozycji, na ktÛrej wystÍpuje rÛønica znakÛw.
Jeøeli
d≥ugoúÊ napisÛw jest rÛøna (a znaki napisÛw sπ takie same w czÍúci
okreúlanej
przez dlugoúc krÛtszego napisu) - zwracana jest rÛønica dlugoúci:<br>
this.length() - anotherString.length().<br><br>
Oznacza to, øe wynik jest ujemny, gdy ten (this) ≥aÒcuch poprzedza
leksykograficznie (alfabetycznie) argument (anothetString) oraz dodatni
- gdy ten ≥aÒcuch jest leksykograficznie wiÍkszy od argumentu.<br></td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">compareToIgnoreCase(String str)</span><br>
PorÛwnuje leksykograficznie dwa napisy, bez rozrÛønienia ma≥ych i
wielkich liter.</td></tr><tr><td align="right" valign="top" width="1%"> boolean</td><td><span style="font-weight: bold;">endsWith(String suffix)</span><br>
Zwraca true, gdy napis koÒczy siÍ ≥aÒcuchem znakowym podanym jako
argument, false - w przeciwnym razie.</td></tr><tr><td align="right" valign="top" width="1%"> boolean</td><td style="width: 70%;"><span style="font-weight: bold;">equals(Object
anObject)</span><br>
Zwraca true gdy anObject jest takim samym co do zawartoúci napisem jak
ten napis; w kaødym innym przypadku - zwraca false.</td></tr><tr><td align="right" valign="top" width="1%"> boolean</td><td><span style="font-weight: bold;">equalsIgnoreCase(String
anotherString)</span><br> J.w. - ale bez rozrÛøniania
ma≥ych i wielkich liter.</td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">indexOf(String str)</span><br>
Zwraca indeks pozycji pierwszego wystπpienia w danym napisie napisu
podanego jako argument str; jeøeli str nie wystÍpuje w tym napisie -
zwraca
-1</td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">indexOf(String str, int fromIndex)</span><br>
Poszukuje pierwszego wystπpienia
napisu str poczynajπc od pozycji oznaczonej przez indeks fromIndex;
zwraca
indeks pozycji na ktÛrej zaczyna siÍ str lub - 1 gdy str nie wystÍpuje
w tym napisie.<br>
Jeúli fromIndex jest ujemne lub zero - przeszukiwany jest ca≥y napis;
jeúli
fromIndex jest wiÍksze od d≥ugoúci napisu - zwracane jest -1.<br></td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">lastIndexOf(String str)</span><br>
Jak indexOf - ale zwracany jest indeks pozycji ostatniego wystπpienia.</td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">lastIndexOf(String str, int
fromIndex)</span><br> J.w.<br>
Uwaga: metody indexOf i lastIndexOf majπ rÛwnieø swoje wersje dla
argumentÛw - znakÛw (typu char).<br></td></tr><tr><td align="right" valign="top" width="1%"> int</td><td><span style="font-weight: bold;">length()</span><br>
Zwraca d≥ugoúÊ napisu.</td></tr><tr><td align="right" valign="top" width="1%"> String</td><td><span style="font-weight: bold;">replace(char oldChar, char
newChar)</span><br> Zwraca nowy obiekt klasy String, w
ktÛrym zastπpiono wszystkie wystπpienia znaku oldChar na znak newChar.</td></tr><tr><td style="vertical-align: top; text-align: right; white-space: nowrap;">String</td><td><span style="font-weight: bold;">replace(CharSequence&nbsp;target,
CharSequence&nbsp;replacement)</span><br>Zwraca nowy
obiekt&nbsp;klasy String, w ktÛrym zastπpiono wszystkie wystπpienia
podnapisu target na napis replacement.</td></tr><tr><td style="text-align: right; vertical-align: top;">String</td><td><span style="font-weight: bold;">replaceAll(String regex, String
replacement)</span><br>Zwraca
nowy obiekt klasy String, w ktÛrym zastπpiono wszystkie wystπpienia
podnapisÛw pasujπcych do wzorca podanego przez wyraøenie regularne
regex na napis target.</td></tr><tr><td style="text-align: right; vertical-align: top;">String</td><td><span style="font-weight: bold;">split(String&nbsp;regex)</span><br>Rozk≥ada
napis na jego podnapisy rozdzielone dowolnymi separatorami, pasujπcymi
do wzorca regex.</td></tr><tr><td align="right" valign="top" width="1%"> boolean</td><td><span style="font-weight: bold;">startsWith(String prefix)</span><br>
Zwraca true, gdy napis zaczyna siÍ podanym jako argument ≥aÒcuchem
znakowym; false - w przeciwnym razie.</td></tr><tr><td align="right" valign="top" width="1%"> boolean</td><td><span style="font-weight: bold;">startsWith(String prefix, int
toffset)</span><br> Zwraca true, gdy pod≥aÒcuch
tego ≥aÒcucha znakowego zaczynajπcy siÍ na pozycji o indeksie toffset
zaczyna
siÍ napisem prefiks; zwraca false w przeciwnym razie, lub gdy toffset
jest
&lt; 0 albo wiÍkszy od dlugoúci napisu.</td></tr><tr><td align="right" valign="top" width="1%"> String</td><td><span style="font-weight: bold;">substring(int beginIndex)</span><br>
Zwraca pod≥aÒcuch tego ≥aÒcucha znakowego zaczynajπcy siÍ na pozycji o
indeksie beginIndex (do koÒca ≥aÒcucha).</td></tr><tr><td align="right" valign="top" width="1%"> String</td><td><span style="font-weight: bold;">substring(int beginIndex, int
endIndex)</span><br> Zwraca pod≥aÒcuch tego ≥aÒcucha jako
nowy obiekt
klasy String. Pod≥aÒcuch zaczynay siÍ na pozycji o indeksie beginIndex,
a koÒczy (uwaga!) - na pozycji o indeksie endIndex-1. D≥ugoúÊ
podlaÒcucha
rÛwna jest endIndex - beginIndex.</td></tr><tr><td align="right" valign="top" width="1%"> char[]</td><td><span style="font-weight: bold;">toCharArray()</span><br>
Znaki ≥aÒcucha -&gt; do tablicy znakÛw (typ char[]).</td></tr><tr><td align="right" valign="top" width="1%"> String</td><td><span style="font-weight: bold;">toLowerCase()</span><br>
Zamiana liter na ma≥e.</td></tr><tr><td align="right" valign="top" width="1%"> String</td><td><span style="font-weight: bold;">toUpperCase()</span><br>
Zamiana liter na duøe.</td></tr><tr><td align="right" valign="top" width="1%"> String</td><td><span style="font-weight: bold;">trim()</span><br>
Usuwa znaki spacji, tabulacji, koÒca wiersza itp. tzw. biale znaki
z obu koÒcÛw ≥aÒcucha znakowego. Zwraca wynik jako nowy ≥aÒcuch.</td></tr><tr><td align="right" valign="top" width="1%">static
String</td><td><span style="font-weight: bold;">valueOf(boolean
b)</span><br> Zwraca wartoúÊ boolowskπ (boolean) jako napis
(String).</td></tr><tr><td align="right" valign="top" width="1%">static String</td><td><span style="font-weight: bold;">valueOf(char c)</span><br>
Zwraca wartoúÊ typu char jako napis.</td></tr><tr><td align="right" valign="top" width="1%">static
String</td><td><span style="font-weight: bold;">valueOf(char[]
data)</span><br> Zwraca napis z≥oøony ze znakow tablicy. </td></tr><tr><td align="right" valign="top" width="1%">static
String</td><td><span style="font-weight: bold;">valueOf(double
d)</span><br> Zwraca znakowπ treprezentacjÍ liczby typu
double.</td></tr><tr><td align="right" valign="top" width="1%">static String</td><td><span style="font-weight: bold;">valueOf(float f)</span><br>
Zwraca znakowπ treprezentacjÍ liczby typu float.</td></tr><tr><td align="right" valign="top" width="1%">static
String</td><td><span style="font-weight: bold;">valueOf(int
i)</span><br> Zwraca znakowπ treprezentacjÍ liczby typu int.</td></tr><tr><td align="right" valign="top" width="1%">static
String</td><td><span style="font-weight: bold;">valueOf(long
l)</span><br> Zwraca znakowπ reprezentacjÍ liczby typu long.</td></tr></tbody>
</table><br>W
pierwszym przyk≥adowym programie wykorzystamy metodÍ charAt(),
zwracajπcπ znak znajdujπcy siÍ w napisie na podanej pozycji oraz
emetody length() i equals().<br><br><img style="width: 297px; height: 218px; float: right;" alt="r" src="./Przetwarzanie danych_ napisy i liczby_files/Wycieczki.jpg">Problem: napisaÊ program, ktÛry
prosi uøytkownika o wybranie jednej z moøliwych
wycieczek oznaczanych duøymi literami A, B, C ..., po czym podaje cenÍ
tej
wycieczki. Miejsca docelowe wycieczek oraz ich ceny majπ byÊ zapisane w
tablicach, np.:<br>
<br> String[] dest = { "Bali", "Cypr", "Ibiza", "Kenia", "Kuba" };<br>
double[] price = { 5000, 2500, 2800, 4500, 6000 };<br>
<br>a program winien dawaÊ uøytkownikowi moøliwoúÊ wyboru za
pomocπ pokazanego obok okna dialogowego.<br>
<br>A zatem uøytkownik wprowadza napis, sk≥adajπcy siÍ z jednej
litery "A" lub "B" lub "C', ... itd.<br>
Dalsze dzia≥anie programu zaleøy od tego jakπ literÍ wprowadzil.<br>
Jeúli res oznacza wprowadzony napis, to moglibyúmy np. napisaÊ:<br>
<br>if (res.equals("A")) System.out.println(dest[0] + " - cena: "
+ price[0]);<br>
else if (res.equals("B")) System.out.println(dest[1] + " - cena: " +
price[1]);<br> else if (res.equals("C")) ..<br> else if
(res.equals("D")) ...<br> else if (res.equals("E")) ..<br>
else ...<br>
<br>Ale jest to doúÊ uciπøliwe i nieeleganckie. Naraøone na
b≥Ídy. Trudne do modyfikacji.<br>
<br>A przecieø wprowadzona litera daje nam natychmiastowe
odniesienie do odpowiednich
elementÛw tablic dest i price. Litera to znak. Znak ma swÛj kod. Kod
jest
liczbπ. £atwo jest wiÍc przekszta≥ciÊ znaki w odpowiednie indeksy
tablic.
<br>Znak A powinien daÊ indeks 0, znak B - indeks 1, znak C -
indeks 2.<br>
Zauwaømy, øe: 'A' - 'A' = 0 , 'B'- 'A' = 1, 'C' - 'A' = 2 ...<br>
Zatem wyliczenie odpowiedniego indeksu moøna zapisac tak:<br>
indeks = &lt;wprowadzony_znak&gt; - 'A'<br>
<br>No, ale musimy jeszcze siÍgnπÊ po ten znak. Z dialogu
dostajemy napis (≥aÒcuch
znakowy). To jest dana typu String, a nie char. Napis ten sk≥ada siÍ z
jednego znaku,
znajdujπcego siÍ na pierwszej pozycji ≥aÒcucha (czyli pod indeksem 0).
Znak
ten otrzymamy stosujπc metodÍ <b>charAt</b> z klasy String.<br>
<br>Jeúli res oznacza wprowadzony napis, to - zamiast poprzedniej
"piÍtrowej" konstrukcji if-else moøemy po prostu napisaÊ:<br>
<br> int i = res.charAt(0) - 'A';<br>
System.out.println(dest[i] + " - cena: " + price[i]);<br>
<br><br>
Ca≥y program pokazano poniøej.<br>
<pre>import static javax.swing.JOptionPane.*;

public class Wycieczki {

  public static void main(String[] args) {

    String[] dest  = { "Bali", "Cypr", "Ibiza", "Kenia", "Kuba" };
    double[] price = { 5000, 2500, 2800, 4500, 6000 };

    String msg = "Wybierz kierunek - " +
                 " wpisujπc literÍ A-"+ (char) ('A'+dest.length-1)+ ":\n";

    for (int i=0; i &lt; dest.length; i++)
      msg += (char) ('A' + i) + " - " + dest[i] + '\n';

    String res;
    while ((res = showInputDialog(msg)) != null) {
      if (res.length() == 1) { 
        int i = res.toUpperCase().charAt(0) - 'A';
        if (i &lt; 0 || i &gt; dest.length -1) continue;
        showMessageDialog(null, dest[i] + " - cena: " + price[i]);
      }
    }
  }

}
</pre><div style="text-align: right;"><span style="font-style: italic;">Zobacz demo programu.</span><applet style="font-style: italic;" codebase="demo" code="starterApplet.StarterApplet.class" archive="StarterApplet.jar" align="right" height="70" vspace="20" width="250">
<param name="className" value="wycieczki.Wycieczki">
<param name="title" value="Demo programu Wycieczki"><param name="sourceCode" value="wycieczki/source.html">
<param name="hasArgs" value="no"><param name="hasConsole" value="no">
</applet>
<br></div><br>Dodatkowe
komentarze:<br>
<ul><li>zastosowano statyczny import JOptionPane - moøna
wiÍc pisaÊ krÛcej showInputFialog i showMessageDialog,</li><li>w
oknie dialogowym wprowadzania danych tekst komunikatu (msg) sk≥ada
siÍ z kilku wierszy; tekst dzielimy na wiersze za pomocπ znaku '\n',</li><li>program
napisano w taki sposÛb, øe przy zmianie liczby wycieczek naleøy
zmieniÊ tylko inicjacje tablic dest i price; inne fragmenty kodu nie
ulegnπ
zmianie,</li><li>przy tworzeniu komunikatu (msg) znowu
wykorzystano moøliwoúÊ traktowania
znakÛw jako liczb (kody znakÛw); jednak operacje arytmetyczne na
znakach
dajπ w wyniku wartoúci typu int, a poniewaø chcemy pokazaÊ znak , a nie
jego
kod (int) - to musimy jawnie przekszta≥ciÊ te wartoúci do typu char -
stπd
koniecznoúÊ uøycia operatora konwersji (char),</li><li>dopuszczamy
by, uøytkownik wprowadzi≥ ma≥π literÍ zamiast duøej; w celu
ujednolicenia stosujemy metodÍ toUpperCase().</li><li>jest
sprawdzana poprawnoúÊ&nbsp;napisu: musi siÍ sk≥adaÊ dok≥adnie z
jednego znaku (sprawdzamy length()) i&nbsp;czy mieúci siÍ w
przedziale A-E (if sprawdza zakres kodÛw).<br></li></ul><br>
SprÛbujmy teraz rozwiπzaÊ inne zadanie. Wyobraümy sobie, øe mamy
dokument
html o prostej strukturze, w ktÛrym kolejne tytu≥y punktÛw treúci
znajdujπ
siÍ miÍdzy znacznikami &lt;h2&gt; ... &lt;/h2&gt;
(tekst zawarty pomiÍdzy
otwierajπcym znacznikiem &lt;h2&gt; i zamykajπcym znacznikiem
&lt;/h2&gt;
- traktowany jest jako nag≥Ûwek drugiego poziomu i odpowiednio do tego
formatowany
przy wyúwietlaniu w przeglπdarce).<br>
Naszym zadaniem jest odnalezienie wszystkich takich nag≥ÛwkÛw i
stworzenie z nich tekstu, ktÛry zawiera kaødy tytu≥ w nowej linii.<br>
Niech&nbsp;klasa realizujπca to zadanie (trochÍ na wyrost) nazywa
siÍ Toc. Przy tworzeniu obiektu
tej klasy przekazujemy konstruktorowi ca≥y dokument HTML w postaci
≥aÒcucha
znakowego, a wywo≥anie metody String getToc() - ma zwrÛciÊ napis ze
wszystkimi nag≥Ûwkami
drugiego poziomu, rozdzielonymi separatorami nowego wiersza. Otrzymanπ
"listÍ"&nbsp; moøemy
nastÍpnie wypisaÊ na konsoli lub zapisaÊ do pliku.&nbsp;<br><br>
Jak podejúÊ do tego problemu?<br>
W tekúcie dokumentu musimy kolejno znajdowaÊ poczπtki nag≥ÛwkÛw
("&lt;h2&gt;"),
a nastÍpnie "wy≥uskiwaÊ" pod≥aÒcuchy, ktÛre sπ zawarte pomiÍdzy
znacznikami
"&lt;h2&gt;" i "&lt;/h2&gt;". Do znajdowania napisÛw w
napisie s≥uøy metoda
indexOf, do "wy≥uskiwania" pod≥acuchÛw metod substring. Uwaga:
powinniúmy
zastosowaÊ tÍ wersjÍ metody indexOf, ktÛra zaczyna poszukiwanie od
podanej
pozycji ≥aÒcucha i wraz z postÍpem przeszukiwania odpowiednio zmieniaÊ
tÍ
pozycjÍ.<br>
<br>Klasa Toc moøe wyglπdaÊ tak.<br><pre>package toc;

public class Toc {

   private String doc;           // przekazany dokument
   private String toc = "";      // wynikowy spis treúci

   // separator koÒca wiersza; poniewaø jest zaleøny od systemu
   // pobieramy go jako wartoúÊ tzw. w≥aúciwoúci systemowej

   private final String ls = System.getProperty("line.separator");

   public Toc(String doc) { // Konstruktor
     this.doc = doc;
   }

  public String getToc() throws IllegalStateException {

     int p = 0; // pozycja od ktÛrej zaczynamy szukanie "&lt;h2&gt;"

     while ((p = doc.indexOf("&lt;h2&gt;", p)) != -1) { // dopÛki sπ "&lt;h2&gt;"

       // poszukajmy znacznika zamykajπcego
       // end jest indeksem pozycji na ktÛrej on wystÍpuje

       int end = doc.indexOf("&lt;/h2&gt;", p+4);

       // jeøeli go nie ma ...

       if (end == -1) throw new IllegalStateException("Invalid document structure");

       // w przeciwnym razie: wy≥uskujemy nag≥Ûwek
       toc += doc.substring(p+4, end) + ls;  // ls - separator wierszy

       p = end + 5;  // i przesuwamy pozycjÍ od ktÛrej bÍdziemy dalej szukaÊ
     }

     return toc;
  }
}</pre><i>
Uwaga: w przypadku braku zamykajπcego znacznika &lt;/h2&gt;
zg≥aszany
jest wyjπtek IllegalStateException. Jest on pochodny od klasy
RuntimeExecption, wiÍc wo≥ajπcy metodÍ getToc() moøe go obs≥ugiwaÊ bπdü
nie. Mimo &nbsp;to w celach dokumentacyjnych wymieniono wyjπtek w
klauzuli throws. Ta wersja programu jest oczywiúcie niedoskona≥a
-&nbsp; nie obs≥uguje przypadku wadliwej struktury
dokumentu, gdy znacznik &lt;h2&gt; wystÍpuje pomiÍdzy
znacznikami
&lt;h2&gt;
i &lt;/h2&gt;.<br>
</i><br><a name="ind.NapLicz.20"></a>Przy okazji tego programu wykorzystaliúmy moøliwoúÊ
pobierania w≥aúciwoúci systemowych. Za pomocπ odwo≥ania:<br>
<br> System.getProperty("line.separator") <br>
<br> zapytaliúmy Javy jaki na danej platformie systemowej
obowiπzuje separator
wierszy (w plikach), Zauwaømy, øe rÛøne systemy stosujπ rÛøne
separatory (np.
pod Unixem jest to 0a , a pod Windows 0d0a - szesnastkowo). Poniewaø
nasz
spis treúci chcemy zapisywaÊ do pliku to musimy uøyÊ znaku separatora
wierszy.
A zgodnie z za≥oøeniami Javy (wieloplatformowoúÊ) powinniúmy
przygotowaÊ
program tak by dzia≥a≥ bez rekompilacji na kaødej platformie. Nb za
pomocπ metody getProperty z klasy System moøemy pobieraÊ rÛøne inne
w≥aúciwoúci systemowe (zob. ich spis w dokumentacji Javy).<br><br>Do
testowania&nbsp;klasy Toc moøna wykorzystaÊ nastÍpujπcy programik,
ktÛry wczytuje dokument HTML z pliku, a spis treúci zapisuje do innego
pliku. <br><pre>import java.io.*;
import java.util.*;
import static javax.swing.JOptionPane.*;

public class MainToc {

  public static void main(String[] args) throws Exception {
    Scanner fnameScan = new Scanner(showInputDialog("in out ?"));
    File in = new File(fnameScan.next());
    BufferedWriter out = new BufferedWriter(new FileWriter(fnameScan.next()));
    Scanner inScan = new Scanner(in);
    StringBuffer sb = new StringBuffer();
    try {
      while (inScan.hasNextLine())
        sb.append(inScan.nextLine());
      inScan.close();
      Toc toc = new Toc(sb.toString());
      out.write(toc.getToc());
    } finally {
      out.close();
    }
  }

}</pre>Nazwy
plikÛw sa pobierane z dialogu wejúciowego. &nbsp;Skaner fnameScan
wyrÛønia je z tekstu wpisanego w dialogu, skaner inScan czyta wiersze
pliku wejúciowego i tworzy z nich jeden d≥ugi tekst w StringBufferze.
Tekst ten jest przekazywany klasie Toc, a otrzymany wynikowy spis
treúci zapisywany do pliku wyjúciowego. Warto zwrÛciÊ uwagÍ na obs≥ugÍ
wyjatkÛw. Metoda main wymienia klasÍ Exception w klauzuli throws, co
zwalnia&nbsp; z ich obs≥ugi w kodzie. Mimo to, zastosowano blok
try,
tym razem bez øadnego catch, ale za to z finally, po to by zapewniÊ
zamkniÍcie pliku wyjúciowego w kaødej sytuacji (czy powsta≥ jakiú
wyjπtek czy nie).<br><hr style="width: 100%; height: 2px;"><br>
<a name="NapLicz.4"></a><h2>4.  RozbiÛr tekstÛw i StringTokenizer</h2>
<br><a name="ind.NapLicz.21"></a>Wyobraümy sobie np., øe ≥aÒcuch znakowy zawiera napisy
reprezentujπce liczbÍ
ca≥kowitπ, dowolnπ (&gt;1) liczbÍ spacji, znak operacji
arytmetycznej, dowolnπ (&gt;1) liczbÍ
spacji i napis reprezentujπcy drugπ liczbÍ ca≥kowitπ. Naszym zadaniem
jest
"wy≥uskanie" z ca≥ego napisu napisÛw-liczb, przekszta≥cenie ich do
postaci
binarnej i wykonanie na nich podanej operacji.<br><img style="border: 1px solid ; width: 195px; height: 158px; float: right;" alt="r" src="./Przetwarzanie danych_ napisy i liczby_files/symbole.jpg"><br>
Napis taki moøe wyglπdaÊ nastÍpujπco: "21 + 21"<br><br>
Wy≥uskiwane symbole sπ rozdzielone <b>separatorami</b>.<br>
W przyk≥adzie z liczbami separatorami bÍdπ spacje.<br>
Dowolny ciπg znakÛw, ktÛry nie zawiera spacji - bÍdzie symbolem.<br>
Dowolna liczba spacji (&gt;1)bÍdzie oddzielaÊ symbole od siebie.<br><br><a name="ind.NapLicz.22"></a>Do wy≥uskiwania symboli z ≥aÒcuchÛw znakowych moøna uøyÊ klasy
StringTokenizer z pakietu java.util.<br>
Po to by dokonaÊ rozbioru tekstu - tworzymy obiekt klasy
StringTokenizer,
podajπc jako argument konstruktora - tekst do rozbioru np.<br>
<br><pre>String expr = "21 + 21";
StringTokenizer st = new StringTokenizer(expr);
</pre>
Ta postaÊ konstruktora zaklada domyúlnie, øe separatorami sπ znaki z
nastÍpujacego zestawu <code>" \t\n\r\f"</code> (czyli znak
spacji, tabulacji, przejúcia do nowego wiersza, powrotu karetki,
nowej strony - tzw. "Bia≥e znaki"). W tym przypadku symbolami bÍdπ ciπgi znakÛw, ktÛre nie
zawierajπ
øadnego z wymienionych separatorÛw.<br>
<br>Obiektu klasy StringTokenizer moøemy teraz zapytaÊ o to ile
symboli zawiera przekazany konstruktorowi napis:<br>
<pre>int n = st.countTokens(); // n = 3</pre><br>
Wy≥uskiwanie symboli odbywa siÍ sekwencyjnie poczynajπc od poczπtku
≥aÒcucha. S≥uøy temu metoda <b>nextToken()</b>
, ktÛra zwraca kolejny symbol jako String. Pierwsze wywo≥anie tej
metody
zwrÛci pierwszy symbol, nastÍpne - bÍdπ zwracaÊ kolejne symbole
≥aÒcucha.
<br><pre>String s1 = st.nextToken(); // napis "21"
String s2 = st.nextToken(); // napis "+"
String s3 = st.nextToken(); // napis "21"
</pre>
Gdy nie ma juø symboli "do zwrotu" - wywo≥anie nextToken() spowoduje
powstanie wyjπtku NoSuchElementException.<br>
<br>Zatem zawsze przeglπdamy ≥aÒcuch od poczπtku i "wy≥uskujπc"
symbole przesuwamy
siÍ do jego koÒca (uwaga: kolejne symbole sπ zwracane, ale oczywiúcie -
nie
sπ usuwane z ≥aÒcucha).<br>
<br>Do stwierdzenia, czy w ≥aÒcuchu znakowym sπ jeszcze symbole
do zwrotu s≥uøy metoda hasMoreTokens().<br>
Metoda hasMoreTokens() zwraca true, jeúli w ≥aÒcuchu znakowym sπ
jeszcze
nie "wyluskane" symbole i false w przeciwnym razie. Inaczej mÛwiπc:
hasMoreTokens()
zwraca true, jeúli nastÍpne odwo≥anie do nextToken() zwrÛci kolejny
symbol
i zwraca false, gdy ew. nastÍpne odwo≥anie do nextToken() spowoduje
wyjπtek
NoSuchElementException.<br>
<br>£atwo zapisaÊ pÍtle, w ktÛrej bÍdziemy pobieraÊ kolejne
symbole:
<pre>while (st.hasMoreTokens()) {
  Sring s = st.nextToken();
  // ... tu coú robimy z s
}
</pre><br>
Wiedzπc to wszystko moøna teraz napisaÊ program, ktÛry w oknie
dialogowym
prosi uøytkownika o wprowadzeia liczby ca≥kowitej, spacji, operatora,
spacji
i drugiej liczby i wykonuje øπdanπ operacjÍ arytmetycznπ na tych dwÛch
liczbach. Jeúli uøytkownik wprowadzi≥ wadliwe dane, to program prosi go
o ich poprawienie. Pierwsza wersja tego programu moøe wyglπdaÊ tak:<br><pre>import java.util.*;
import static javax.swing.JOptionPane.*;

public class Oper {

  public static void main(String[] args) {

    String normalQuest = "Liczba1 op Liczba2",     // normalny komunikat
           errorQuest = "Wadliwe dane. Popraw.\n", // komunikat w przypadku b≥Ídu
           quest = normalQuest;

    String expr = "";                              // wyraøenie do obliczenia 

    while ((expr = showInputDialog(quest, expr)) != null) {

      StringTokenizer st = new StringTokenizer(expr);

      if (st.countTokens() != 3) {  // jeøeli za ma≥o lub za duøo symboli
          quest = errorQuest;
          continue;
      }

      String snum1 = st.nextToken(),   // pierwsza liczba (napisowo)
             sop  = st.nextToken(),    // symbol operatora
             snum2 = st.nextToken();   // druga liczba (napisowo)
      
      int num1 = 0, num2 = 0, res = 0; // liczbt do obliczeÒ i wynik 
      
      try {
        num1 = Integer.parseInt(snum1);
        num2 = Integer.parseInt(snum2);
      } catch (NumberFormatException exc) { // jeøeli napisy nie sπ liczbami ca≥kowitymi
          quest = errorQuest;               // komunikat o b≥Ídzie 
          continue;
      }
      
      char op = sop.charAt(0);
      
      // jezeli napis oznaczajπcy operator za d≥ugi (np. ktoú wprowadzi≥ +*)
      // lub gdy w ilorazie dzialnik jest zerem - b≥πd
      if (sop.length() != 1 || (op == '/' &amp;&amp; num2 == 0)) {  
        quest = errorQuest;
        continue;
      }

      switch (op) {
        case '+' : res = num1 + num2; break;
        case '-' : res = num1 - num2; break;
        case '*' : res = num1 * num2; break;
        case '/' : res = num1 / num2; break;
        default: {                           // wadliwy operator
          quest = errorQuest;
          continue;
        }
      }
      showMessageDialog(null, "Wynik = " + res);
      quest = normalQuest;
      expr = "";            // w kolejnym dialogu inicjalny tekst ma byÊ pusty
    }

  }

}</pre>Uwaga:
w programie zastosowano wersjÍ metody showInputDialog, w ktÛrej drugi
argument oznacza inicjalny napis umieszczony w polu tekstowym dialogu.
Normalnie bÍdzie to pusty tekst, ale w przypadku b≥Ídu umieúcimy w polu
tekstowym b≥Ídny napis, tak aby od razu moøna go by≥o poprawiÊ.<br><br>Na
marginiesie warto zauwaøyÊ, øe ten program moøna napisaÊ znacznie
krÛcej, korzystajπc ze zg≥aszania wyjπtkÛw i ich uogÛlnionej obs≥ugi,
co pokazuje poniøszy kod. <br><pre>import java.util.*;
import static javax.swing.JOptionPane.*;

public class Oper1 {

  public static void main(String[] args) {

    String normalQuest = "Liczba1 op Liczba2",
           errorQuest = "Wadliwe dane. Popraw.\n" + normalQuest,
           quest = normalQuest,
           expr = "";

    while ((expr = showInputDialog(quest, expr)) != null) {
      int res;
      try {
        StringTokenizer st = new StringTokenizer(expr);
        int num1 = Integer.parseInt(st.nextToken());
        String sop = st.nextToken();
        int num2 = Integer.parseInt(st.nextToken());
        
        if (sop.length() != 1 || st.hasMoreTokens()) 
          throw new IllegalArgumentException();
      
        
        switch (sop.charAt(0)) {
          case '+' : res = num1 + num2; break;
          case '-' : res = num1 - num2; break;
          case '*' : res = num1 * num2; break;
          case '/' : res = num1 / num2; break;
          default  : throw new IllegalArgumentException();
        }
      } catch (Exception exc) {
        quest = errorQuest;
        continue;
      }
      showMessageDialog(null, "Wynik = " + res);
      quest = normalQuest;
      expr = "";
    }
    
  }

}</pre><div style="text-align: right;"><span style="font-style: italic;">Zobacz demo programu</span><applet style="font-style: italic;" codebase="demo" code="starterApplet.StarterApplet.class" archive="StarterApplet.jar" align="right" height="70" vspace="20" width="250">
<param name="className" value="oper.Oper1"><param name="title" value="Demo programu Oper1"><param name="sourceCode" value="oper/source.html">
<param name="hasArgs" value="no"><param name="hasConsole" value="no"></applet><span style="font-style: italic;">
</span><br></div><br>Tutaj, w przypadku za
ma≥ej liczby symboli powstaje wyjπtek NoSuchElementException. Jeúli
napisy-argumenty nie dajπ siÍ zinterpretowaÊ jako liczby ca≥kowite -
NumberFormatExcepetion. Gdy mamy dzielenie przez zero -
ArithmeticException. Inne b≥Ídy (za duøo symboli, za d≥ugi napis na
oznaczenie operatora, nieznany operator) sygnalizujemy sami zg≥aszajπc
wyjπtek IllegalArgumentException. Wszystkie te wyjπtki (a zatem b≥Ídy)
sπ obs≥ugiwane w jednym miejscu i kod jest bardziej zwarty, logiczny.
&nbsp;<br><br>
Inna postaÊ konstruktora klasy StringTokenizer pozwala na okreúlenie
zbioru
separatorÛw, ktÛre bÍdπ s≥uøyÊ do wyrÛøniania symboli.<br>
Jeøeli napiszemy np.<br>
<br>StringTokenizer st = new StringTokenizer(s, "., " - to
sepaartorami bÍdπ kropka, przecinek i spacja.<br>
<br>Zadanie:<br> StworzyÊ klasÍ Words, ktÛrej obiekty bÍdπ
zawieraÊ tablicÍ
s≥Ûw napisu przekazanego jako argument konstruktora. Za s≥owa uznajemy
ciπgi
znakÛw rozdzielonych spacjami i znakami interpunkcji.<br>
W klasie dostarczyÊ metod:<br>
getWordsCount() - zwraca liczbÍ s≥Ûw<br>
getWord(int i) - zwraca i-te s≥owo napisu (i =1,2, ... n; gdzie n
liczba s≥Ûw w napisie)<br>
getWords() - zwraca tablicÍ s≥Ûw<br>
getMaxLenWord() - zwraca najd≥uøsze s≥owo<br>
getMinLenWord() - zwraca najkrÛtsze s≥owo<br>
<br>Moøliwe rozwiπzanie:<br><br><pre>import java.util.*;

public class Words {

  private String[] words;      // tablica slÛw
  private String maxLenWord;   // s≥owo o max d≥ugoúci
  private String minLenWord;   // s≥owo o minimalnej d≥ugoúci

  // Konstruktor
  public Words(String txt) throws IllegalArgumentException {

    // Sprawdzamy czy przekazano w≥aúciwy argument
    if (txt == null) 
      throw new IllegalArgumentException("Wadliwy argument konstruktora Words: null"); 

    // UwzglÍdniamy bogaty zestaw separatorÛw s≥Ûw
    StringTokenizer st = new StringTokenizer(txt, " \t\n\r\f.,:;()[]\"'?!-{}");
     
    int n = st.countTokens();      // ile s≥Ûw?
    if (n == 0) 
      throw new IllegalArgumentException("Wadliwy argument konstruktora Words: napis nie zawiera s≥Ûw");
    
    words = new String[n];         // utworzenie tablicy s≥Ûw
    words[0] = st.nextToken();     // pierwsze s≥owo
    int maxL = words[0].length(),  // max i min d≥ugoúÊ (na razie = d≥ugoúci pierwszego s≥owa)
        minL = maxL;                          

    int i = 1;                     // kolejny indeks w tablicy

    while (st.hasMoreTokens()) {   // dopÛki sπ slowa
      String s = st.nextToken();
      int len = s.length();
      if (len &gt; maxL) {            // maksymalna d≥ugoúÊ ?
         maxL = len;
         maxLenWord = s;
      }
      if (len &lt; minL) {            // minimalna d≥ugoúÊ ?
        minL = len;
        minLenWord = s;
      }
      words[i++] = s;              // slowo -&gt; do tablicy; zwiÍkszenie indeksu
    }
  }

  // Zwraca liczbÍ s≥Ûw
  public int getWordsCount() {
    return words.length;
  }

  // Zwraca i-te s≥owo (liczymy od 1)
  // jeúli podano wadliwy indeks - zwraca null
  public String getWord(int i) {
    return (i &lt; 1 || i &gt; words.length) ? null : words[i-1];
  }

  // Zwraca tablicÍ slÛw
  public String[] getWords() {
    return words;
  }

  // Zwraca slowo o max d≥ugoúci
  public String getMaxLenWord() {
    return maxLenWord;
  }
  // Zwraca slowo o min d≥ugoúci
  public String getMinLenWord() {
    return minLenWord;
  }


}</pre>I
klasa testujπca:<br><pre>import static javax.swing.JOptionPane.*;

public class TestWords {

  public static void main(String[] args) {
    String txt;
    while ((txt = showInputDialog("Wpisz tekst")) != null) {
      Words w = new Words(txt);
      int n = w.getWordsCount();
      System.out.println("Liczba s≥Ûw: " + n);
      System.out.println("Kolejne slowa: ");
      for (int i=1; i &lt;= n; i++) System.out.println(w.getWord(i));
      int iw = Integer.parseInt(showInputDialog("Podaj numer s≥owa:"));
      System.out.println("S≥owo o numerze " + iw + ": " + w.getWord(n+1));
      System.out.println("Kolejne slowa: ");
      String[] words = w.getWords();
      for (String wrd : words) System.out.println(wrd);
      System.out.println("Najdluøsze s≥owo: " + w.getMaxLenWord());
      System.out.println("NajkrÛtsze s≥owo: " + w.getMinLenWord());
    }
  }

}</pre><div style="text-align: right;"><span style="font-style: italic;">Zobacz demo dzia≥ania programu.</span><applet codebase="demo" code="starterApplet.StarterApplet.class" archive="StarterApplet.jar" align="right" height="70" vspace="20" width="250">
<param name="className" value="words.TestWords"><param name="title" value="Demo programu Words"><param name="sourceCode" value="words/source.html">
<param name="hasArgs" value="no"><param name="hasConsole" value="yes"></applet>
<br></div><br>
Java udostÍpnia rÛwnieø szereg innych sposobÛw sk≥adniowej analizy tekstÛw.
Klasa StreamTokenizer (podobna do StringTokenizer) dostarcza nieco bardziej
zaawansowanych sposobÛw rozbioru tekstu, ale wymaga operowania na strumieniach.<br>
Gdy mamy do czynienia z dokumentami HTML - moøemy zastosowaÊ parsery HTML (ze standardu
Javy lub zewnÍtrzne). Do przetwarzania dokumentÛw XML standardowa wersja Javy
przeznacza&nbsp; bogate i rÛønorodne úrodki.<br><br>Bardzo mocne i elastyczne moøliwoúci analizy sk≥adniowej dajπ teø <i><b>wyraøenia regularne</b></i>.<br><hr style="width: 100%; height: 2px;"><br>
<a name="NapLicz.5"></a><h2>5.  Wyraøenia regularne</h2>
<a name="ind.NapLicz.23"></a>W dokumentacji klasy StringTokenizer moøna przeczytaÊ, øe do rozbioru tekstÛw lepiej jest stosowaÊ metodÍ split z klasy String. <br>Wywo≥anie: <br><br>&nbsp;&nbsp;&nbsp; txt.split(sep);<br><br>zwraca tablicÍ symboli napisu <span style="font-style: italic;">txt</span> rozdzielonych separatorami pasujπcymi do wzorca podanego przez napis - wyraøenie regularne <span style="font-style: italic;">sep</span>. <br><br>Trzeba wiÍc pamiÍtaÊ o tym, øe w metodzie split podajemy jako argument
wyraøenie regularne. NiezbÍdna jest zatem
wiedza o sk≥adni i znaczeniu wyraøeÒ regularnych. Bez tego ≥atwo jest
wpaúÊ w pu≥apkÍ i otrzymaÊ nieoczekiwane wyniki. <br>Przyk≥adowe rÛønice w dzia≥aniu StringTokenizera i&nbsp; metody split pokazuje poniøsza tablica.<br><br><table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="1" rowspan="2" style="text-align: center;">Tekst<br>txt</td><td colspan="1" rowspan="2" style="text-align: center;">Separator<br>sep</td><td colspan="2" rowspan="1">StringTokenizer st = <br>&nbsp; &nbsp; &nbsp;new StringTokenizer(txt, sep)</td><td colspan="2" rowspan="1">String[] s = txt.split(sep)</td></tr><tr><td style="text-align: center;">Liczba <br>symboli: <br>st.countTokens()</td><td style="text-align: center;"><br>WyrÛønione<br>symbole: <br>st.nextToken()<br>&nbsp;</td><td style="text-align: center;">Liczba<br>symboli: <br>s.length</td><td style="text-align: center;">WyrÛønione <br>symbole: <br>s[i]</td></tr><tr><td>1</td><td>"ala ma kota i psa"</td><td style="text-align: center;">" "</td><td style="text-align: center;">5</td><td>0: Ala<br>1: ma<br>2: kota<br>3: i<br>4: psa</td><td style="text-align: center;">5</td><td>0: Ala<br>1: ma<br>2: kota<br>3: i<br>4: psa</td></tr><tr><td>2</td><td>"ala ma kota &nbsp;i &nbsp;psa"</td><td style="text-align: center;">" "</td><td style="text-align: center;">5</td><td>0: Ala<br>1: ma<br>2: kota<br>3: i<br>4: psa</td><td style="text-align: center;">7</td><td>0: Ala<br>1: ma<br>2: kota<br>3: <br>4: i<br>5: <br>6: psa</td></tr><tr><td>3</td><td>"Pierwszy.Drugi.Trzeci"</td><td style="text-align: center;">"."</td><td style="text-align: center;">3</td><td>0: Pierwszy<br>1: Drugi<br>2: Trzeci</td><td style="text-align: center;">0</td><td></td></tr></tbody></table><br><br>W
przypadku (1) wyniki sπ identyczne, ale podobieÒstwo jest mylπce.
Przypadek (2) pokazuje, øe split traktuje separator bardzo dos≥ownie: ma to
byÊ jedna spacja. W tekúcie wyszukiwane sπ podnapisy ograniczane
separatorem (jednπ spacjπ) lub koÒcem wiersza. Dlatego, jako wyrÛønione
&nbsp;symbole pojawiπ siÍ (na pozycji 3 i 5) puste podnapisy (np.
podnapis "kota" na poz. 2 ograniczony jest spacjπ, za niπ jest jeszcze
jedna spacja - pomiÍdzy tymi dwoma spacjami znajdzie siÍ wiÍc element -
pusty podnapis). &nbsp;Po to, by uzyskaÊ zamierzony (taki sam jak przy
uøyciu StringTokenizera) efekt trzeba w split podaÊ wyraøenie regularne
"jedna lub wiÍcej spacji", co zapisujemy za pomocπ tzw. kwantyfikatora
&nbsp;+: " +".<br><pre>String[] s = txt.split(" +");</pre>da w wyniku tablicÍ wszystkich podnapisÛw napisu txt rozdzielonych co najmniej jednπ spacjπ.<br><br>W
przypadku (3) StringTokenizer bardzo ≥adnie rozbi≥ podany tekst na
separatorze "." (kropka), natomiast metoda split nie wyrÛøni≥a øadnych
symboli. Sta≥o siÍ tak dlatego, øe kropka w sk≥adni wyraøeÒ regularnych
ma specjalne znaczenie (dowolny znak), wobec tego w tekúcie nie ma
øadnego podnapisu zakoÒczonego separatorem (sπ tylko same separatory).
Aby uøyÊ w &nbsp;wyraøeniu regularnym znaku, ktÛry ma specjalne
znaczenie naleøy go poprzedziÊ odwrotnym ukoúnikiem, przy czym ze
wzglÍdu na to, øe odwrotny ukoúnik ma w zapisie StringÛw znaczenie
"symbolu ucieczki" musimy zapisaÊ go literalnie jako dwa odwrotne
ukoúniki.<br>Zatem dopiero poprzez:<br><pre>String[] s = txt.split("\\.");&nbsp;</pre>uzyskamy tablicÍ podnapisÛw napisu txt rozdzielonych kropkπ.<br><br>W&nbsp;
prostych przypadkach uøycie StringTokenizera moøe siÍ wydaÊ
wygodniejsze, ale jest wiele sytuacji, w ktÛrych za jego pomocπ nie
sposÛb osiπgnπÊ wymaganego efektu i wtedy wyraøenia regularne mogπ
okazaÊ siÍ bardzo pomocne.<br>Na pewno wiÍc warto siÍ z nimi
zaznajomiÊ. Tutaj przedstawione zostanie tylko kilka ogÛlnych
informacji wprowadzajπcych w to zagadnienie, a takøe krÛtkie praktyczne przyk≥ady. WiÍcej szczegÛ≥Ûw
moøna uzyskaÊ z dokumentacji.<br><br><br><div class="def"><a name="ind.NapLicz.24.NapLicz.24"></a>Regularne wyraøenie stanowi opis wspÛlnych cech (sk≥adni) zbioru ≥aÒcuchÛw znakowych</div><br>
<br>
Moøemy sobie wyobraøaÊ, øe regularne wyraøenie jest pewnym wzorcem, ktÛry
opisuje jeden lub wiele napisÛw, pasujπcych do tego wzorca. Wzorzec taki
zapisujemy za pomocπ specjalnej sk≥adni wyraøeÒ regularnych.<br>
<br>
Najprostszym wzorcem jest po prostu sekwencja znakÛw, ktÛre nie majπ specjalnego znaczenia (sekwencja <b>litera≥Ûw</b>).<br>
Np. wyraøenie regularne abc stanowi wzorzec opisujπcy trzy wystÍpujπce po
sobie znaki: a, b, i c. Wzorzec ten opisuje jeden napis "abc".<br>
<br>
We wzorcach moøemy stosowaÊ znaki specjalne (tzw. <b>metaznaki</b>) oraz tworzone za ich pomocπ konstrukcje sk≥adniowe. Do znakÛw specjalnych naleøπ:<br>
<br>
<table border="1" cellpadding="4" width="300">
<tbody><tr><td>$</td><td>^</td><td>.</td><td>*</td><td valign="top"><br>
      </td>
</tr><tr><td>+</td><td>?</td><td>[</td><td>]</td><td valign="top"><br>
      </td>
</tr><tr><td>(<br>
</td><td>)&nbsp;</td><td>{&nbsp;</td><td>}<br>
</td><td valign="top">\<br>
      </td>
</tr></tbody>
</table>
Uwagi: <br>
<ol><li>jeúli chcemy traktowaÊ znaki specjalne jako litera≥y - poprzedzamy je odwrotnym ukoúnikiem \.</li><li>w niektÛrych konstrukcjach sk≥adniowych metaznaki tracπ specjalne znaczenie i sπ traktowane literalnie.</li></ol>Za pomocπ znakÛw specjalnych i tworzonych za ich pomocπ bardziej rozbudowanych konstrukcji sk≥adniowych opisujemy m.in.
<ul><li><a name="ind.NapLicz.25"></a>wystπpienie <span style="font-weight: bold;">jednego</span> z wielu znakÛw - odpowiednie konstrukcje sk≥adniowe noszπ nazwÍ <b>klasy znakÛw</b>:</li><ul><li>prosta klasa znakÛw stanowi ciπg znakÛw ujÍtych w nawiasy kwadratowe np. [123abc] okreúla dowolny ze znakÛw 1, 2, 3, a, b, c,</li><li>zakres znakÛw (zapisywany z uøyciem -), np. [0-9] - dowolna cyfra,</li><li>negacja klasy znakÛw - jeúli pierwszym znakiem w nawiasach kwadratowych jest <b>^</b>, to dopasowanie nastπpi dla kaødego znaku <b>oprÛcz</b> wymienionych na liúcie.&nbsp;<br>
Np. do wzorca [^abc] bÍdzie pasowa≥ kaødy znak oprÛcz a, b i c,</li><li>klasy predefiniowane (wprowadzane za pomocπ specjalnych symboli) np.</li><ul><li>.&nbsp;(kropka) - klasa wszystkich znakÛw (kaødy znak pasuje do tego&nbsp;wzorca),</li><li>\d - cyfra, \D - nie-cyfra,</li><li>\w - jeden ze znakÛw: [a-zA-Z0-9] (znak dopuszczalny w s≥owie),</li><li>\p{Punct} -znak interpunkcji - skrÛt dla [!
"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~]</li><li>\p{L} - dowolna litera (Unicode).</li></ul></ul><li><a name="ind.NapLicz.26"></a>poczπtek lub koniec ograniczonego ciπgu znakÛw (np. wiersza lub s≥owa) - <b>granice</b>,</li><ul><li>np. ^ poczπtek wiersza, $ - koniec wiersza,</li></ul><li><a name="ind.NapLicz.27"></a>powtÛrzenia - w sk≥adni wyraøeÒ regularnych opisywane przez tzw. <b>kwantyfikatory,</b></li><ul><li>np. kwantyfikator * oznacza wystπpienie 0 lub wiÍcej razy, a kwantyfikator +&nbsp;wystπpienie co najmniej jeden raz.&nbsp;</li><li>
w przypadku gdy kwantyfikator nastÍpuje po literale - wymagane jest wystπpienie
(liczba wystπpieÒ zaleøy od kwantyfikatora, w szczegÛlnoúci moøe byÊ 0) tego
litera≥u np. "12a+" oznacza 1, potem 2, nastÍpnie wystπpienie znaku 'a' jeden
lub wiÍcej razy (uwaga: "12a+" nie oznacza wystπpienia ciπgu znakÛw 12a jeden lub wiÍcej razy),</li><li>
gdy kwantyfikator wystÍpuje po klasie znakÛw - dotyczy dowolnego znaku z
tej klasy. Np. [abc]+ oznacza wystπpienie jeden lub wiÍcej razy znaku a,
lub znaku b, lub znaku c,</li><li>
jeúli natomiast chcemy, by kwantyfikator dotyczy≥ dowolnego wyraøenia regularnego <b>X</b> - &nbsp;to powinniúmy zastosowaÊ jednπ z poniøszych konstrukcji sk≥adniowych:<br>
<b>(X)<i>symbol_kwantyfikatora</i><br>
(?:X)<i>symbol_kwantyfikatora</i></b><br>
Konstrukcje takie tworzπ tzw. grupy. Grupy ujÍte w nawiasy okrπg≥e (pierwsza
z w/w form sk≥adniowych) s≥uøπ teø do zapamiÍtywania tekstu pasujπcego
do wzorca podanego w nawiasach (moøemy siÍ pÛüniej do tego dopasowania odwo≥aÊ). Druga forma s≥uøy wy≥πcznie grupowaniu, bez
zapamiÍtywania. Przyk≥ad: (?:12a)+ - jedno lub wiÍcej wystπpieÒ napisu "12a";</li><li>kwantyfikatory
mogπ byÊ: <span style="font-weight: bold;">zach≥anne</span> (domyúlnie) lub <span style="font-weight: bold;">wstrzemiÍüliwe</span>. Przy zastosowaniu
kwantyfikatorÛw zach≥annych uzyskujemy najd≥uøsze moøliwe dopasowanie
np. regularne wyraøenie "1.3" zastosowane wobec tekstu "123123"
dopasuje ca≥y tekst "123123". Kwantyfikatory wstrzemiÍüliwe odnajdujπ
moøliwie najkrÛtsze dopasowanie, wprowadza siÍ je poprzez dodanie znaku
zapytania do kwantyfikatora np. wyraøenie regularne "1.*?3" w tekúcie
"123123" dopasuje podnapis "123";</li></ul><li><span style="font-weight: bold;">flagi</span>, ktÛre modyfikujπ sposÛb interpretacji wyraøenia regularnego, np.:&nbsp;</li><ul><li>(?i) porÛwnywanie liter bez uwzglÍdnienia ich wielkoúci,</li><li>(?s) dopasowanie kropki (symbolu dowolnego znaku) rÛwnieø do znaku koÒca wiersza;</li></ul><li>logiczne kombinacje wyraøeÒ regularnych, np. &nbsp;a+|b - jedno lub wiÍcej wystπpieÒ znaku a lub znak b.<br>
  </li></ul><br>
WyraøeÒ regularnych moøemy uøyÊ m.in. do: <br>
<ul><li>stwierdzenia czy dany napis pasuje do podanego przez wyraøenie wzorca,</li><li>stwierdzenia czy dany napis zawiera pod≥aÒcuch znakowy pasujπcy do
podanego wzorca i ew. uzyskania tego podnapisu i/lub jego pozycji w napisie,</li><li>zamiany czÍúci napisu, pasujπcych do wzorca na inne napisy,</li><li>wyrÛøniania czÍúci napisu, ktÛre sπ rozdzielane ciπgami znakÛw pasujπcymi do podanego wzorca. </li></ul><a name="ind.NapLicz.28"></a>W Javie do najogÛlniejszego pos≥ugiwania siÍ wyraøeniami regularnymi s≥uøπ klasy pakietu java.util.regex: <b>Pattern i Matcher</b>.<br>
<br>
Przed zastosowaniem wyraøenia regularnego do sk≥adniowej analizy jakiegoú napisu musi ono byÊ skompilowane. Obiekty klasy <b>Pattern</b> reprezentujπ skompilowane wyraøenia regularne, a obiekty te uzyskujemy za pomocπ statycznych metod klasy Pattern - <b>compile(...)</b>, majπcych za argument tekst wyraøenia regularnego.<br>
Obiekty klasy <b>Matcher</b> wykonujπ operacje wyszukiwania&nbsp;
w tekúcie za pomocπ interpretacji skompilowanego wyraøenia regularnego i
dopasowywania go do tekstu lub jego czÍúci.<br>
Obiekt-matcher jest zawsze zwiπzany z danym wzorcem. Zatem uzyskujemy go od obiektu-wzorca za pomocπ metody <b>matcher(...)</b>
&nbsp;klasy Pattern, podajπc jako jej argument przeszukiwany tekst. NastÍpnie
moøemy dokonywaÊ rÛønych operacji przeszukiwania i zastÍpowania tekstu poprzez
uøycie rÛønych metod klasy Matcher. <br>
W szczegÛlnoúci: <br>
<ul><li>metoda <b>matches()</b> stara siÍ dopasowaÊ do wzorca ca≥y podany ≥aÒcuch znakowy i zwraca true, jeúli siÍ to uda≥o, false w przeciwnym razie,</li><li>metoda <b>find()</b>&nbsp; przeszukuje wejúciowy ≥aÒcuch znakowy i wyszukuje kolejne pasujπce do wzorca jego pod≥aÒcuchy,</li><li>metoda <span style="font-weight: bold;">group()</span> zwraca ostatnio dopasowany tekst,</li><li>metoda <span style="font-weight: bold;">start()</span> zwraca poczπtkowπ pozycjÍ ostatnio dopasowanego tekstu,</li><li>metoda <span style="font-weight: bold;">end()</span> zwraca koÒcowπ pozycjÍ ostatnio dopasowanego tekstu,</li><li>metoda <span style="font-weight: bold;">group(int n)</span> zwraca n-tπ grupÍ (n &gt;=1) ostatnio dopasowanego tekstu (grupy w wyraøeniu regularnym&nbsp;oznaczamy nawiasami okrπg≥ymi),</li><li>metoda <span style="font-weight: bold;">replaceFirst(String rpl)</span>
zastÍpuje pierwsze wystπpienie dopasowanego tekstu tekstem podanym jako
rpl (w tekúcie zastÍpujπcym moøemy odwo≥ywaÊ siÍ do zapamiÍtanych grup),</li><li>metoda<span style="font-weight: bold;"> replaceAll(String rpl)</span>
zastÍpuje wszystkie wystπpienia dopasowanego tekstu tekstem podanym w
rpl (w tekúcie zastÍpujπcym moøemy odwo≥ywaÊ siÍ do zapamiÍtanych grup).</li></ul>Do rozbioru tekstÛw s≥uøπ natomiast metody <span style="font-weight: bold;">split(...) </span>z klasy Pattern.<br><br><a name="ind.NapLicz.29"></a>Przyk≥ady.<br><br><span style="font-weight: bold;">A. Metoda matches() stwierdza czy ca≥y tekst pasuje do wzorca.</span><br><pre>import java.util.regex.*;

public class Sample1 {

  public static void main(String[] args) {
    // Wzorzec: jedno lub wiÍcej wystπpieÒ dowolnej cyfry
    String regex = "[0-9]+";

    // Kompilacja wzorca
    Pattern pattern = Pattern.compile(regex);

    // Tekst wejúciowy 
    String txt = "196570";
    
    // Uzyskanie matchera
    Matcher matcher = pattern.matcher(txt);

    // Czy tekst pasuje do wzorca?

    boolean match = matcher.matches();

    System.out.println("Tekst: " + txt + '\n' + 
                       (match ? " " : " NIE ") + "pasuje do wzorca: " + regex);

    // Nowy tekst wejúciowy
    txt = "123 996";
    // reset matchera "zeruje" jego stany i pozwala teø na podanie nowego tekstu
    matcher.reset(txt);
    match  = matcher.matches();
    System.out.println("Tekst: " + txt + '\n' + 
        (match ? " " : " NIE ") + "pasuje do wzorca: " + regex);
  }

}</pre>wynik:<br><div class="listing100">Tekst: 196570<br>&nbsp;pasuje do wzorca: [0-9]+<br>Tekst: 123 996<br>&nbsp;NIE pasuje do wzorca: [0-9]+<br></div><br><span style="font-weight: bold;">B. Metoda find() odnajduje w napisie kolejne podnapisy pasujπce do wzorca.</span><br style="font-weight: bold;"><br><pre>iimport java.util.regex.*;

public class Sample2 {

  public static void main(String[] args) {
    // Wzorzec: jedno lub wiÍcej wystπpieÒ dowolnej cyfry
    String regex = "[0-9]+";

    // Tekst wejúciowy 
    String txt = "123 996";
    
    System.out.println("Tekst: \n" + "'" + txt + "'" + 
                       "\nWzorzec: " + "'" + regex + "'");

    // Kompilacja wzorca
    Pattern pattern = Pattern.compile(regex);

    // Uzyskanie matchera
    Matcher matcher = pattern.matcher(txt);
    
    String result = "";  // do prezentacji wynikÛw wyszukiwania
    
    // Zastosujemy metodÍ find()
    // Jej wywo≥anie zwraca true po znalezieniu pierwszego
    // pasujπcego do wzorca pod≥aÒcucha w tekúcie.
    // Kolejne wywo≥ania pozwalajπ wyszukiwaÊ kolejne pasujπce pod≥aÒcuchy;
    // wynik false oznacza, øe w tekúcie nie ma pasujπcych pod≥aÒcuchÛw
    
    while (matcher.find()) {
      result += "\nDopasowano pod≥aÒcuch '" + 
        matcher.group() + "'" +                // group() zwraca ostatni dopasowany tekst 
        "\nod pozycji " + matcher.start() +    // start() zwraca jego poczatkowπ pozycjÍ
        "\ndo pozycji " + matcher.end();       // end() zwraca pozycjÍ po ostatnim dopasowanym znaku
    }
    
 
    if (result.equals("")) result = "Nie znaleziono øadnego podnapisu " +
                                    "pasujπcego do wzorca";
    System.out.println(result);
  }

}</pre>wynik:<br><div class="listing100">Tekst: <br>'123 996'<br>Wzorzec: '[0-9]+'<br><br>Dopasowano pod≥aÒcuch '123'<br>od pozycji 0<br>do pozycji 3<br>Dopasowano pod≥aÒcuch '996'<br>od pozycji 4<br>do pozycji 7<br><br></div><br><span style="font-weight: bold;">C.
Uøywajπc grup (ujmujπc odpowiednie fragmenty wyraøenia regularnego w
&nbsp;nawiasy okrπg≥e) moøemy ≥atwo wy≥uskiwaÊ fragmenty dopasowanego
tekstu.</span><br><pre>import java.util.regex.*;

public class Sample3 {

  public static void main(String[] args) {
    // Wzorzec: 
    // jedno lub wiÍcej wystπpieÒ dowolnej cyfry (grupa, bo w nawiasach)
    // po czym jeden lub wiÍcej bia≥ych znakÛw
    // po czym jedna lub wiÍcej liter Unicode (grupa 2, w nawiasach)
    // po czym jeden lub wiÍcej bia≥ych znakÛw
    // po czym dowolna liczba ca≥kowita &gt; 1 (grupa 3, w nawiasach)
    
    String regex = "<span style="color: rgb(255, 0, 0); font-weight: bold;">([0-9]+)</span>\\s+<span style="color: rgb(51, 51, 255); font-weight: bold;">(\\p{L}+)</span>\\s+<span style="color: rgb(0, 153, 0); font-weight: bold;">([1-9][0-9]*)</span>";

    // Tekst wejúciowy 
    String txt = "1111 Odkurzacz 20";
    
    System.out.println("Tekst: " + "'" + txt + "'" + 
                       "\nWzorzec: " + "'" + regex + "'");

    // Kompilacja wzorca
    Pattern pattern = Pattern.compile(regex);

    // Uzyskanie matchera
    Matcher matcher = pattern.matcher(txt);
    
    // Dopasowanie tekstu
    boolean isMatching = matcher.matches();
    if (isMatching) {
      int n = matcher.groupCount();      // ile jest grup
      for (int i = 1; i &lt;=n; i++) {
        String grupa = matcher.group(i); // pobranie zawartoúci i-ej grupy (numeracja od 1)
        System.out.println("Grupa " + i + 
                           " = '" + grupa + "'");
      }
    } else System.out.println("Tekst nie pasuje do wzorca");
    
  }

}</pre>wynik:<br><div class="listing100">Tekst: '1111 Odkurzacz 20'<br>Wzorzec: '([0-9]+)\s+(\p{L}+)\s+([1-9][0-9]*)'<br>Grupa 1 = '1111'<br>Grupa 2 = 'Odkurzacz'<br>Grupa 3 = '20'<br></div><br><span style="font-weight: bold;">D. Uøywajπc metody split() z klasy Pattern moøna dokonaÊ rozbioru tekstu</span><br><pre>public class Sample4 {

  public static void main(String[] args) {
    // ogÛlny wzorzec separatorÛw do wyrÛøniania s≥Ûw:
    // separatorem jest 1 lub wiÍcej "bia≥ych znakÛw" lub znakÛw interpunkcji
    String regex = "[\\s\\p{Punct}]+";

    // Tekst wejúciowy 
    String txt = "Ala(11), kot,; pies-1 &lt;kot2&gt;[mrÛwka]";
    
    // Kompilacja wzorca
    Pattern pattern = Pattern.compile(regex);
    String[] words = pattern.split(txt);     // inaczej wo≥ane niø  split() z klasy String
    
    System.out.println("Liczba wyrÛønionych s≥Ûw: " + words.length);
    for (String w : words) {
      System.out.println(w);
    }
  }

}</pre>wynik:<br><div class="listing100">Liczba wyrÛønionych s≥Ûw: 7<br>Ala<br>11<br>kot<br>pies<br>1<br>kot2<br>mrÛwka<br><br></div><br><span style="font-weight: bold;">E. Metoda replaceFirst &nbsp;usuwa z napisu pierwsze wystπpienie podnapisu pasujπcego do wzorca</span><br><pre>import java.io.*;
import java.util.*;
import java.util.regex.*;

public class Sample5 {

  public static void main(String[] args) throws Exception {
    
    // Usuniemy z tekstu z pliku wszystkie komentarze jednowierszowe 
    // (zaczynajπce siÍ od dwÛch ukosnikÛw - sk≥adnia jak w Javie)
    // wynik zapiszemy do innego pliku
    
    Scanner in = new Scanner(new File("test1.txt"));    // skaner dla pliku wejúciowego
    BufferedWriter out = new BufferedWriter(
                          new FileWriter("test2.txt")); // plik wyjúciowy

    // Wzorzec komentarzy:
    // 0 lub wiÍcej bia≥ych znakÛw, potem dwa ukosniki po ktÛrych wystÍpujπ bπdü nie inne znaki
    String regex = "\\s*//.*";
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(""); 
    
    try {
      while (in.hasNextLine()) {
        String line = in.nextLine();
        matcher.reset(line);
        String nline = matcher.replaceFirst("");  // komentarz zastÍpujemy pustym napisem
        if (!nline.equals("")) {                  // wynikowy wiersz zapiszemy, jeúli nie jest pusty
          out.write(nline);
          out.newLine();
        }
      }
    } finally {
      in.close();
      out.close();
    }
  }

}</pre>wynik:<br><div class="listing100"><span style="text-decoration: underline;">Przyk≥adowy plik wejúciowy</span><br>tekst<br>// to jest komentarz<br>a tu jest tekst // i komentarz // cos tam<br>&nbsp; // kom1<br>&nbsp; // kom2<br>idzie dalej tekst <br><br><span style="text-decoration: underline;">Wygenerowany plik wyjúciowy</span><br>tekst<br>a tu jest tekst<br>idzie dalej tekst<br></div><br><span style="font-weight: bold;">F.
W tekúcie zastÍpujπcym dopasowanie w metodach replaceFirst i replaceAll
moøemy odwolywaÊ siÍ do zawartoúci grup wyraøenia regularnego.</span><br><pre>import java.util.regex.*;

public class Sample6 {

  public static void main(String[] args) throws Exception {
    
    // Zastπpimy w tekúcie wszystkie napisy:
    // (liczbaCa≥kowita1:liczbaCa≥kowita2)
    // na napisy:
    // [liczbaCa≥kowita2:liczbaCa≥kowita1]
    // czyli zmienimy nawiasy na kwadratowe i przestawimy miejscami liczby
   
    // Wzorzec:
    // nawias,liczba,dwukropek,liczba, nawias - uwaga nawias jest znakiem specjalnym - uzyjemy ukoúnika
    // zastosujemy dwie grupy: dla liczby1 i liczby2 
    String regex = "\\(<span style="color: rgb(0, 153, 0); font-weight: bold;">(\\d)</span>:<span style="color: rgb(255, 0, 0); font-weight: bold;">(\\d)</span>\\)";
    Pattern pattern = Pattern.compile(regex);
    
    String txt = "tekst 1 (ale) (2) (1:2) wo≥anie f() (3:4) (8:9)(10:11)";  
    Matcher matcher = pattern.matcher(txt);
    
    // W wywo≥aniu metody replaceAll (i replaceFirst) podajπc tekst zastÍpujπcy
    // moøemy  odwo≥ywaÊ siÍ do zawartoúci grup wzorca.
    // Wtedy tekst zastÍpujπcy bÍdzie zawiera≥ zawartoúÊ grupy z dopasowania wyraøenia.
    // W tekúcie zastÍpujπcyn stosujemy znak $ z nastÍpujπcym po nim numerem grupy 
    // (a wiÍc znak $ jest w tym kontekúcie zarezerwowany!)
    // W naszym przyk≥adzie mamy dwie grupy: pierwszπ liczbÍ i drugπ liczbÍ
    // oznaczamy je $1 i $2
    
    // zamiana nawiasÛw i przestawienie liczb
    String newTxt = matcher.replaceAll("[$2:$1]");
    
    System.out.println("Tekst przed zamianπ:");
    System.out.println(txt);
    System.out.println("Tekst po zamianie:");
    System.out.println(newTxt);
  }

}</pre><br><hr style="width: 100%; height: 2px;"><br>
<a name="NapLicz.6"></a><h2>6.  Uproszczenia stosowania wyraøeÒ regularnych w klasach String i Scanner</h2>
<a name="ind.NapLicz.30"></a>

Jako pewne uproszczenie, do zastosowaÒ ad hoc, znajdziemy w klasie String
metody, ktÛre odwzorowujπ niektÛre z omÛwionych metod klas Matcher i Pattern.<br>
Sπ one nastÍpujπce.<br>
  <br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">&nbsp;boolean</td><td>matches(String&nbsp;regex)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy <i><b>ten</b></i> napis pasuje do wzorca regex?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">&nbsp;String</td><td>replaceAll(String&nbsp;regex,
           String&nbsp;replacement)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZastÍpuje kaødy pasujπcy do regex pod≥aÒcuch <i><b>tego</b></i> napisu podanym napisem replacement. Uwaga: znaki $ i \ majπ specjalne znaczenie (zob. przyk≥ad F z poprzedniego punktu).</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">&nbsp;String</td><td>replaceFirst(String&nbsp;regex,
             String&nbsp;replacement)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZastÍpuje pierwszy pasujπcy do regex pod≥aÒcuch <i><b>tego</b></i> napisu podanym napisem replacement. Uwaga: j.w.</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">&nbsp;String[]</td><td>split(String&nbsp;regex)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rozklada ten
napis wokÛ≥ separatorÛw, ktÛre sπ pod≥ancuchami pasujπcymi do wzorca</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">&nbsp;String[]</td><td>split(String&nbsp;regex,
      int&nbsp;limit)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j.w., ale nie wiÍcej niø limit-1 razy<br>
        <br>
</td></tr></tbody>
  </table>
  <br>
Metody te sπ úcis≥ymi odpowiednikami odpowiednich metod klas Matcher i Pattern.
Faktycznie, "wewnÍtrznie" wykorzystujπ one w≥aúnie te klasy i ich metody.
Np. jeúli txt jest typu String, to<br>
txt.matches("[0-9]+");<br>
jest toøsame z :<br>
Pattern.compile("[0-9]+").matcher().matches();<br>
  <br>
Oznacza to, øe tych "skrÛconych" metod klasy String powinniúmy uøywaÊ wy≥πcznie
wtedy, gdy dane wyraøenie regularne i zwiπzany z nim matcher uøywane sπ jednokrotnie.
Przy wielokrotnym uøyciu nalezy najpierw wyraøenie skompilowaÊ (raz), po
czym dopiero wielokrotnie uøyÊ, co oczywiúcie juø wymaga wykorzystania klas
Pattern i Matcher.<br><br><a name="ind.NapLicz.31"></a>Klasa Scanner mocno korzysta z wyraøeÒ regularnych.<br><ul><li>Po
pierwsze, zestaw separatorÛw, na ktÛrych skaner rozk≥ada teksty metodπ
next() jest wyraøeniem regularnym. Domyúlnie jest to wyraøenie,
okreúlajπce bia≥e znaki (spacja, tabulacja itp.), ale moøemy go zmieniÊ
uøywajπc metody&nbsp;<span style="font-weight: bold;">useDelimiter(String regex)</span> lub <span style="font-weight: bold;">useDelimiter(Pattern p)</span>. Metoda reset() przywraca domyúlny wzorzec separatorÛw. Co wiÍcej,&nbsp; separatory moøemy zmieniaÊ w trakcie skanowania,</li><li>Po drugie, dodatkowe metody: <span style="font-weight: bold;">next(String regex)</span> i <span style="font-weight: bold;">next(Pattern p)</span>&nbsp;zwracajπ kolejny symbol&nbsp;ograniczony&nbsp; separatorami <span style="font-weight: bold;">oraz</span>&nbsp;pasujπcy
do wzorca podanego w wyraøeniu regularnym i ustawiajπ pozycjÍ skanera
zaraz za nim. W przypadku jeúli kolejny symbol nie pasuje do wzorca,
zg≥aszany jest wyjπtek NoSuchElementException. Odpowiednie metody
hasNext(wyraøenie_regularne) pozwalajπ stwierdziÊ, czy&nbsp;symbol jest
dostÍpny. Niejako odwrotnoúciπ&nbsp; metod next(...) sπ metody <span style="font-weight: bold;">skip(...)</span>,
ktÛre pomijajπ separatory oraz kolejny symbol pasujπcy do wzorca i
ustawiajπ pozycjÍ skanera zaraz za nim. Przy braku dopasowania pozycja
siÍ nie zmienia i zg≥aszany jest wyjπtek NoSuchElementException.</li><li>Po trzecie, metody <span style="font-weight: bold;">findInLine(wyraøenie_regularne)</span> i <span style="font-weight: bold;">findWithinHorizon(wyraøenie_regularne, n</span>)
wyszukujπ w tekúcie i zwracajπ napis pasujπcy do wzorca (ignorujπc
separatory), jednoczeúnie przesuwajπc pozycjÍ skanera za ten napis.
Jeúli nie&nbsp;ma pasujπcego napisu zwracana jest wartoúÊ null (nie ma wyjπtku). W
przypadku metody findInLine wyszukiwanie ograniczone jest koÒcem
wiersza, metoda findInHorizon przeszukuje n kolejnych znakÛw (jeúli n
jest 0 - ograniczeniem jest d≥ugoúÊ tekstu).</li><li>Po
czwarte, skaner ≥πczy moøliwoúÊ uøycia wyraøeÒ regularnych z ≥atwym
pobieraniem liczb (np. metoda nextInt). Naleøy jednak pamiÍtaÊ, øe przy
pobieraniu liczb rzeczywistych (z separatorem miejsc dziesiÍtnych)
skaner przyjmuje format ich zapisu (m.in. to czy separatorem miejsc
dziesiÍtnych jest kropka czy przecinek) zgodnie z domyúlnπ lokalizacjπ
(aktualnymi ustawieniami regionalnymi). Uøywanπ przez skaner
lokalizacjÍ moøna zmieniÊ za pomocπ metody skanera <span style="font-weight: bold;">useLocale</span>(..).</li></ul><br><div class="notec">Uøycie
wyraøeÒ regularnych w klasie Skaner jest - podobnie jak w klasie String
- oparte na odwo≥aniach do klas Pattern i Matcher. Ale - inaczej niø w
String - to wykorzystanie jest efektywne, poniewaø stosowane wzorce sπ
kompilowane jednokrotnie i przechowywane w mapach.</div><br>
Przyk≥ady.<br><br><span style="font-weight: bold;">A. Aby uzyskaÊ taki
sam efekt rozbioru jak w przypadku StringTokenizera naleøy zastosowaÊ
wyraøenie regularne opisujπce wystπpienie jeden lub wiÍcej razy
dowolnego znaku z podanego zbioru np. [\\s\\p{Punct}]+ - jeden lub
wiÍcej bia≥ych znakÛw lub znakÛw interpunkcji.</span><br style="font-weight: bold;"><br><pre>import java.util.*;
import static java.lang.System.out;

public class Skaner1 {

  // Metoda pomocnicza do okalania napisÛw apostrofami 
  public static String quote(String s) {  return "'" + s + "'" + " "; }

  public static void main(String[] args) {
    // Zadanie: wyrÛøniÊ wszystkie napisy rozdzielone spacjami lub znakiem / 
    String txt = "1/2 /3/ 4";
        
    // Separator?
    // intuicyjnie jedno z: spacja lub znak /
    String delim = "[ /]";
    
    // Przy tworzeniu skanera od razu moøna ustaliÊ separator
    Scanner scan = new Scanner(txt).useDelimiter(delim);
    
    out.println("Tekst : " + quote(txt) + " Separator: " + quote(delim));
    
    // Ale wynik - podobnie jak w split() inny od oczekiwaÒ
    // ze wzglÍdu na sposÛb dzia≥ania machiny wyraøeÒ regularnych
    
    // uzyskamy 5 symboli zamiast 4: '1' '2' '' '3' '' '4'
    while (scan.hasNext()) out.print( quote(scan.next()) + " ");
    
    // Aby uzyskaÊ taki sam wynik jak w StringTokenizerze
    // nalezy zastosowaÊ wyraøenie regularne: 1 lub wiÍcej spacji lub znakÛw /
    delim = "[ /]+";
    // Uwaga: do nowego skanowania zawsze trzeba tworzyÊ nowys skaner (nawet jeúli tekst jest ten sam)
    
    scan = new Scanner(txt).useDelimiter(delim);  
    
    out.println("\nTekst : " + quote(txt) + " Separator: " + quote(delim));
    
    // uzyskamy 4 symbole : '1' '2', '3' '' '4'
    while (scan.hasNext()) out.print( quote(scan.next()) + " ");

  }

}
</pre>Wynik:<br><div class="listing100">Tekst : '1/2 /3/ 4'&nbsp; Separator: '[ /]' <br>'1'&nbsp; '2'&nbsp; ''&nbsp; '3'&nbsp; ''&nbsp; '4'&nbsp; <br>Tekst : '1/2 /3/ 4'&nbsp; Separator: '[ /]+' <br>'1'&nbsp; '2'&nbsp; '3'&nbsp; '4'&nbsp; </div><br><span style="font-weight: bold;">B. Separatorem moøe byÊ dowolne wyraøenie regularne, np. jakieú fragmenty tekstÛw mogπ byÊ traktowane jako separatory.</span><br style="font-weight: bold;"><pre>import java.util.*;

public class Skaner2 {

  public static void main(String[] args) {
    
    // Zadanie: z napisu (np. jakiegoú dokumentu)
    // wyrÛøniÊ nazwiska, imiona i daty urodzenia
    // wstawione w odpowiednio opisane pola dokumentu
    
    String txt = "LNAME: Kowalski FNAME: Jan BORN: 1980-12-01\n" +
                 "LNAME:  Malinowski FNAME: Stefan BORN: 1950-01-15\n";
    
    // Separator:
    // dowolna z nazw pÛl LNAME: albo FNAME: albo BORN:
    String delim = "(LNAME:)|(FNAME:)|(BORN:)";
    
    Scanner scan = new Scanner(txt).useDelimiter(delim);
    while(scan.hasNext()) {
      String s = scan.next();
      // Poniewaø wy≥uskane symbole mogπ na koÒcach zawieraÊ bia≥e znaki
      // usuniemy je za pomocπ metody trim() z klasy String
      s = s.trim();
      System.out.println( "'" + s + "'");
    }
  }

}
</pre><br>Wynik:<br><div class="listing100">'Kowalski'<br>'Jan'<br>'1980-12-01'<br>'Malinowski'<br>'Stefan'<br>'1950-01-15' </div><br><span style="font-weight: bold;">C. Skaner ≥πczy si≥Í wyraøeÒ regularnych z ≥atwym przekszta≥caniem napisÛw w liczby.</span><br><br><pre>import java.util.*;

public class Skaner3 {

  public static void main(String[] args) {
    
    // Zadanie: zsumowaÊ wszystkie liczby ca≥kowite wystÍpujπce w tekúcie
    
    String txt = "Wydano najpierw 20, a pÛüniej 35.\n" +
                 "W kolejnym dniu zakupiono coú jescze za 1000";
    
    // Separator:
    // 1 lub wiÍcej wystapieÒ nie-cyfry
    // moøna tu uøyÊ klasy znakÛw \D, ale zapiszemy bardziej naocznie: 
    String delim = "[^0-9]+";
    
    Scanner scan = new Scanner(txt).useDelimiter(delim);
    int sum = 0;
    while(scan.hasNextInt()) {
      sum += scan.nextInt();
      
    } 
    System.out.println("Tekst:\n" + txt + "\n\nSuma liczb: " + sum);
  }

}</pre><br>Wynik:<br><div class="listing100">Tekst:<br>Wydano najpierw 20, a pÛüniej 35.<br>W kolejnym dniu zakupiono coú jescze za 1000<br><br>Suma liczb: 1055 </div><br><br><span style="font-weight: bold;">D.
Skaner moøe dzia≥aÊ bezpoúrednio na rÛønych ürÛd≥ach danych i w
dzia≥aniu tym stosowaÊ zaawansowane konstrukcje ze úwiata wyraøeÒ
regularnych (np. pobraÊ matcher i uzyskaÊ od niego dodatkowe potrzebne
informacje). </span><br style="font-weight: bold;"><br><pre>import java.util.*;

public class Skaner4 {
  
  public static void main(String[] args) throws Exception {
    // Znane nam juø zadanie z wyrÛønieniem tytu≥ow rozdzia≥Ûw 
    // (napisy w znacznikach &lt;h2&gt; dokumentu html)
    // w kilku linijkach kodu
     
    // BÍdziemy wczytywaÊ podany plik
    Scanner fScan = new Scanner(new File("TypyOp.html"));

    // Wyraøenie reg. do wy≥uskania tekstu w znacznikach;
    // - kwantyfikator jest wstrzÍmiÍøliwy (znak ? po +) inaczej bylyby k≥opoty
    // - zastosujemy grupÍ (nawiasy), aby od razu mieÊ tekst bez okalajπcych znacznikÛw
    String h2regex = "(?s)&lt;h2&gt;(.+?)&lt;/h2&gt;";
    
    // Metoda findWithinHorizon wyszukuje kolejne wystπpienie 
    // tekstu pasujπcego do wzorca (drugi arg 0 = limit wyszukiwania nieograniczony)
    
    while(fScan.findWithinHorizon(h2regex, 0) != null) {
      
      // Skaner moøe uzyskaÊ Matcher przez odwolanie match()
      // Od Matchera pobierzemy zawartoúÊ jedynej grupy  
      String title = fScan.match().group(1);
      System.out.println(title);
    }
    fScan.close();  // zamykamy skaner i plik
  }
}
</pre><br>Wynik:<br><div class="listing100">1. Litera≥y i zmienne<br>2. PojÍcie typu. Typy proste<br>3. Typy i uøycie litera≥Ûw<br>4. Typy zmiennych. Deklaracje<br>5. Operatory i wyraøenia<br>5.1. Przeglπd<br>5.2. Operatory przypisania<br>5.3. ZwiÍkszanie i zmniejszanie<br>5.4. Dzielenie ca≥kowite i reszta<br>6. Konwersje arytmetyczne<br>7. Podsumowanie<br>8. Zadania i Êwiczenia </div><br><span style="font-weight: bold;">E.
Skaner pozwala na ustalenie i zmiany w trakcie skanowania lokalizacji
(ustawieÒ regionalnych) uøwanej przez niego przy interpretacji
napisÛw, traktowanych jako liczby rzeczywiste z separatorem miejsc
dziesiÍtnych.</span><br style="font-weight: bold;"><br><pre>import java.util.*;

public class Skaner5 {

  public static void main(String[] args) {
    
    // Zadanie: pobraÊ liczby rzeczywiste z tekstu 
    // uwzglÍdniajπc format ich zapisu w≥aúciwy dla podanych lokalizacji
    // Tekst ma postaÊ: symbol_jÍzyka zapis_liczby_zgodny_z_lokalizacjπ ...
    // zsumowaÊ wszystkie liczby
    
    String txt = "en 1.1 fr 2,2 pl 3,3";   
    
    Scanner scan = new Scanner(txt);
    
    // Za≥Ûømy, øe symbol jÍzyka sk≥ada siÍ z dwÛch dowolnych ma≥ych liter
    // BÍdziemy go w tekúcie wyszukiwaÊ za pomocπ poniøszego wzorca
    String langSymRx = "[a-z][a-z]";

    double sum = 0;
    
    // Metoda findInLine znajduje w wierszu kolejny podnapis 
    // pasujπcy do wzorca, jeúli go nie ma - zwraca null
    
    String lang = scan.findInLine(langSymRx);
    while (lang != null) {
      scan.useLocale( new Locale(lang) );
      sum += scan.nextDouble();
      lang = scan.findInLine(langSymRx);
    }  
    
    System.out.println("Tekst:\n" + txt + "\n\nSuma liczb: " + sum);
  }

}

</pre><br>Wynik:<br><div class="listing100">Tekst:<br>en 1.1 fr 2,2 pl 3,3<br><br>Suma liczb: 6.6 </div><br><br>Na
koniec opowieúci o skanerze przyjrzyjmy siÍ jeszcze tylko jednemu
przyk≥adowemu programikowi, przetwarzajπcemu raport o dochodach i
wydatkach.<br>Plik raportu ma nastÍpujπcπ przyk≥adowπ postaÊ:<br><pre>1.dochody: 100,11 21,21 500,80 
2.wydatki: 200,10 11,31 756,21
3.wydatki:  10,61  2,11  25,00
4.dochody:   2,30 99,12 101,11</pre>przy czym liczba i kolejnoúÊ wierszy a takøe iloúÊ liczb w poszczegÛlnych wierszach&nbsp; moøe byÊ rÛøna.<br>Trzeba
zbudowaÊ klasÍ, ktÛra dostarcza &nbsp;metody sumowania poszczegÛlnych
kategorii finansowych (wydatkÛw, dochodÛw). Argumentem metody jest
kategoria ("wydatki"&nbsp;lub "dochody"), a metoda ma zwracaÊ
odpowiednio sumÍ liczb z&nbsp;danej kategorii. Metoda sumowania moøe
byÊ wywo≥ywana wielokrotnie, a to wymaga wielokrotnej interpretacji
treúci pliku. W takich sytuacjach najlepiej jest wczytaÊ plik raz
(jeúli nie jest olbrzymi) i nastÍpnie dzia≥aÊ juø na jego tekúcie
umieszczonym w pamiÍci (jako String).<br><br>Do rozwiπzania problemu zastosujemy skaner, bo za jego pomocπ: <br><ol><li>≥atwo
odnaleüÊ poczπtki sekwencji liczb w danych kategoriach (np. kategorie
dochodÛw znajdzie nam nastÍpujπce wyraøenie regularne
&nbsp;"\d\.dochody:"),</li><li>≥atwo pobieraÊ z tekstu liczby,</li><li>nie
musimy siÍ martwiÊ formatem liczb (wystarczy lokalizacja domyúlna;
zapewne raport jest przygotowany przez ksiÍgowπ, ktÛra np. w Polsce
stosuje przecinek jako separator miejsc dziesiÍtnych),</li><li>do
wczytania ca≥ego pliku wystarczy praktycznie jedna instrukcja (uøycie
jako separatora dla skanera&nbsp; granicy \Z, oznaczajπcej&nbsp;koniec
wejúcia")</li></ol>Program przedstawiono na wydruku.<br><pre>import java.io.*;
import java.util.*;

public class Report {
  
  private String report;       
  
  public double sum(String what) {
    Scanner sc = new Scanner(report);
    String regex = "\\d\\." + what + ":";
    
    if (sc.findWithinHorizon(regex, 0) == null)
      throw new IllegalArgumentException("Brak wymaganej kategorii");

    double sum = 0;
    do {
      while (sc.hasNextDouble()) {
        sum += sc.nextDouble();
      }
    } while (sc.findWithinHorizon(regex, 0) != null);
            
    return sum;
  }
  
  public Report(String fname) throws FileNotFoundException {
    Scanner fs = new Scanner( new File(fname) );
    report = fs.useDelimiter("\\Z").next();
    fs.close();
  }
  
  public static void main(String[] args) throws FileNotFoundException {
    Report rep = new Report("RaportKsiegowej.txt");     
    
    double wydatki = rep.sum("wydatki"),
           dochody = rep.sum("dochody");
    
    System.out.println("Dochody: " + dochody + "\nWydatki: " + wydatki );

  }
}</pre>Dla przyk≥adowego pliku otrzymamy w wyniku:<br><div class="listing100">Dochody: 824.65<br>Wydatki: 1005.34</div><br><br>Wyraøenia
regularne i skaner to mocne narzÍdzia. Ale teø trudne. Ich poprawne
stosowanie wymaga wiedzy o mechanizmach dzia≥ania. Tutaj informacja
taka pojawi≥a siÍ we fragmentach (warto siÍgnπÊ po dodatkowe
materia≥y). Na pewno warto juø teraz, niejako od poczπtku nauki,
stosowaÊ wyraøenia regularne, ale &nbsp;dopÛki nie osiπgniemy w tym
swego rodzaju mistrzostwa - raczej ostroønie i z zastosowaniem
wielokrotnych testÛw.<br>&nbsp;<br><hr>
<a name="NapLicz.7"></a><h2>7.  Podsumowanie</h2>
Zapoznaliúmy siÍ z praktycznymi sposobami przetwarzania tekstÛw m.in.:<br><ul><li>jak wczytywaÊ teksty z plikÛw i zapisywaÊ je do plikÛw,</li><li>jak stosowaÊ niektÛre metody klasy String,</li><li>jak przeprowadzaÊ analizÍ sk≥adniowπ za pomocπ klasy StringTokenizer oraz wyraøeÒ regularnych i klasy Scanner.</li><li>jak wy≥uskiwaÊ z tekstÛw liczby.</li></ul>Jest to wiedza niezbÍdna w praktycznym programowaniu, a opisane tu sposoby dzia≥ania i podejúcia sπ stosowane niemal na codzieÒ.<br><br><hr style="width: 100%; height: 2px;">


</body></html>